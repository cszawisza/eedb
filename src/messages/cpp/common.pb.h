// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common.proto

#ifndef PROTOBUF_common_2eproto__INCLUDED
#define PROTOBUF_common_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_common_2eproto();
void protobuf_AssignDesc_common_2eproto();
void protobuf_ShutdownFile_common_2eproto();

class ResponseCode;
class Filter;
class Filter_FilterComponent;
class Limits;
class OrderBy;
class DateTime;
class DateTime_Unix;
class DateTime_Text;
class DateTime_Date;
class Event;
class TimeLine;

enum Filter_FilterComponent_Operation {
  Filter_FilterComponent_Operation_Equal = 1,
  Filter_FilterComponent_Operation_NotEqual = 2,
  Filter_FilterComponent_Operation_LessThen = 3
};
bool Filter_FilterComponent_Operation_IsValid(int value);
const Filter_FilterComponent_Operation Filter_FilterComponent_Operation_Operation_MIN = Filter_FilterComponent_Operation_Equal;
const Filter_FilterComponent_Operation Filter_FilterComponent_Operation_Operation_MAX = Filter_FilterComponent_Operation_LessThen;
const int Filter_FilterComponent_Operation_Operation_ARRAYSIZE = Filter_FilterComponent_Operation_Operation_MAX + 1;

// ===================================================================

class ResponseCode : public ::google::protobuf::MessageLite {
 public:
  ResponseCode();
  virtual ~ResponseCode();

  ResponseCode(const ResponseCode& from);

  inline ResponseCode& operator=(const ResponseCode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ResponseCode& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResponseCode* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ResponseCode* other);

  // implements Message ----------------------------------------------

  ResponseCode* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResponseCode& from);
  void MergeFrom(const ResponseCode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline bool error() const;
  inline void set_error(bool value);

  // optional uint32 code = 2;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 code() const;
  inline void set_code(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ResponseCode)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_code();
  inline void clear_has_code();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool error_;
  ::google::protobuf::uint32 code_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_common_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_common_2eproto();
  #endif
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static ResponseCode* default_instance_;
};
// -------------------------------------------------------------------

class Filter_FilterComponent : public ::google::protobuf::MessageLite {
 public:
  Filter_FilterComponent();
  virtual ~Filter_FilterComponent();

  Filter_FilterComponent(const Filter_FilterComponent& from);

  inline Filter_FilterComponent& operator=(const Filter_FilterComponent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Filter_FilterComponent& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Filter_FilterComponent* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Filter_FilterComponent* other);

  // implements Message ----------------------------------------------

  Filter_FilterComponent* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Filter_FilterComponent& from);
  void MergeFrom(const Filter_FilterComponent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Filter_FilterComponent_Operation Operation;
  static const Operation Equal = Filter_FilterComponent_Operation_Equal;
  static const Operation NotEqual = Filter_FilterComponent_Operation_NotEqual;
  static const Operation LessThen = Filter_FilterComponent_Operation_LessThen;
  static inline bool Operation_IsValid(int value) {
    return Filter_FilterComponent_Operation_IsValid(value);
  }
  static const Operation Operation_MIN =
    Filter_FilterComponent_Operation_Operation_MIN;
  static const Operation Operation_MAX =
    Filter_FilterComponent_Operation_Operation_MAX;
  static const int Operation_ARRAYSIZE =
    Filter_FilterComponent_Operation_Operation_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required bytes lvalue = 1;
  inline bool has_lvalue() const;
  inline void clear_lvalue();
  static const int kLvalueFieldNumber = 1;
  inline const ::std::string& lvalue() const;
  inline void set_lvalue(const ::std::string& value);
  inline void set_lvalue(const char* value);
  inline void set_lvalue(const void* value, size_t size);
  inline ::std::string* mutable_lvalue();
  inline ::std::string* release_lvalue();
  inline void set_allocated_lvalue(::std::string* lvalue);

  // required .Filter.FilterComponent.Operation operation = 2;
  inline bool has_operation() const;
  inline void clear_operation();
  static const int kOperationFieldNumber = 2;
  inline ::Filter_FilterComponent_Operation operation() const;
  inline void set_operation(::Filter_FilterComponent_Operation value);

  // required bytes rvalue = 3;
  inline bool has_rvalue() const;
  inline void clear_rvalue();
  static const int kRvalueFieldNumber = 3;
  inline const ::std::string& rvalue() const;
  inline void set_rvalue(const ::std::string& value);
  inline void set_rvalue(const char* value);
  inline void set_rvalue(const void* value, size_t size);
  inline ::std::string* mutable_rvalue();
  inline ::std::string* release_rvalue();
  inline void set_allocated_rvalue(::std::string* rvalue);

  // @@protoc_insertion_point(class_scope:Filter.FilterComponent)
 private:
  inline void set_has_lvalue();
  inline void clear_has_lvalue();
  inline void set_has_operation();
  inline void clear_has_operation();
  inline void set_has_rvalue();
  inline void clear_has_rvalue();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* lvalue_;
  ::std::string* rvalue_;
  int operation_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_common_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_common_2eproto();
  #endif
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static Filter_FilterComponent* default_instance_;
};
// -------------------------------------------------------------------

class Filter : public ::google::protobuf::MessageLite {
 public:
  Filter();
  virtual ~Filter();

  Filter(const Filter& from);

  inline Filter& operator=(const Filter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Filter& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Filter* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Filter* other);

  // implements Message ----------------------------------------------

  Filter* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Filter& from);
  void MergeFrom(const Filter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Filter_FilterComponent FilterComponent;

  // accessors -------------------------------------------------------

  // repeated .Filter.FilterComponent component = 1;
  inline int component_size() const;
  inline void clear_component();
  static const int kComponentFieldNumber = 1;
  inline const ::Filter_FilterComponent& component(int index) const;
  inline ::Filter_FilterComponent* mutable_component(int index);
  inline ::Filter_FilterComponent* add_component();
  inline const ::google::protobuf::RepeatedPtrField< ::Filter_FilterComponent >&
      component() const;
  inline ::google::protobuf::RepeatedPtrField< ::Filter_FilterComponent >*
      mutable_component();

  // @@protoc_insertion_point(class_scope:Filter)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Filter_FilterComponent > component_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_common_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_common_2eproto();
  #endif
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static Filter* default_instance_;
};
// -------------------------------------------------------------------

class Limits : public ::google::protobuf::MessageLite {
 public:
  Limits();
  virtual ~Limits();

  Limits(const Limits& from);

  inline Limits& operator=(const Limits& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Limits& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Limits* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Limits* other);

  // implements Message ----------------------------------------------

  Limits* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Limits& from);
  void MergeFrom(const Limits& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 count = 1;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 1;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // required uint32 offset = 2;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 2;
  inline ::google::protobuf::uint32 offset() const;
  inline void set_offset(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Limits)
 private:
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_offset();
  inline void clear_has_offset();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 count_;
  ::google::protobuf::uint32 offset_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_common_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_common_2eproto();
  #endif
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static Limits* default_instance_;
};
// -------------------------------------------------------------------

class OrderBy : public ::google::protobuf::MessageLite {
 public:
  OrderBy();
  virtual ~OrderBy();

  OrderBy(const OrderBy& from);

  inline OrderBy& operator=(const OrderBy& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const OrderBy& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const OrderBy* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(OrderBy* other);

  // implements Message ----------------------------------------------

  OrderBy* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const OrderBy& from);
  void MergeFrom(const OrderBy& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:OrderBy)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_common_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_common_2eproto();
  #endif
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static OrderBy* default_instance_;
};
// -------------------------------------------------------------------

class DateTime_Unix : public ::google::protobuf::MessageLite {
 public:
  DateTime_Unix();
  virtual ~DateTime_Unix();

  DateTime_Unix(const DateTime_Unix& from);

  inline DateTime_Unix& operator=(const DateTime_Unix& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const DateTime_Unix& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DateTime_Unix* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DateTime_Unix* other);

  // implements Message ----------------------------------------------

  DateTime_Unix* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DateTime_Unix& from);
  void MergeFrom(const DateTime_Unix& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed64 d = 1;
  inline bool has_d() const;
  inline void clear_d();
  static const int kDFieldNumber = 1;
  inline ::google::protobuf::uint64 d() const;
  inline void set_d(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:DateTime.Unix)
 private:
  inline void set_has_d();
  inline void clear_has_d();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 d_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_common_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_common_2eproto();
  #endif
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static DateTime_Unix* default_instance_;
};
// -------------------------------------------------------------------

class DateTime_Text : public ::google::protobuf::MessageLite {
 public:
  DateTime_Text();
  virtual ~DateTime_Text();

  DateTime_Text(const DateTime_Text& from);

  inline DateTime_Text& operator=(const DateTime_Text& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const DateTime_Text& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DateTime_Text* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DateTime_Text* other);

  // implements Message ----------------------------------------------

  DateTime_Text* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DateTime_Text& from);
  void MergeFrom(const DateTime_Text& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string date_string = 1;
  inline bool has_date_string() const;
  inline void clear_date_string();
  static const int kDateStringFieldNumber = 1;
  inline const ::std::string& date_string() const;
  inline void set_date_string(const ::std::string& value);
  inline void set_date_string(const char* value);
  inline void set_date_string(const char* value, size_t size);
  inline ::std::string* mutable_date_string();
  inline ::std::string* release_date_string();
  inline void set_allocated_date_string(::std::string* date_string);

  // @@protoc_insertion_point(class_scope:DateTime.Text)
 private:
  inline void set_has_date_string();
  inline void clear_has_date_string();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* date_string_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_common_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_common_2eproto();
  #endif
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static DateTime_Text* default_instance_;
};
// -------------------------------------------------------------------

class DateTime_Date : public ::google::protobuf::MessageLite {
 public:
  DateTime_Date();
  virtual ~DateTime_Date();

  DateTime_Date(const DateTime_Date& from);

  inline DateTime_Date& operator=(const DateTime_Date& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const DateTime_Date& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DateTime_Date* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DateTime_Date* other);

  // implements Message ----------------------------------------------

  DateTime_Date* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DateTime_Date& from);
  void MergeFrom(const DateTime_Date& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 year = 1;
  inline bool has_year() const;
  inline void clear_year();
  static const int kYearFieldNumber = 1;
  inline ::google::protobuf::uint32 year() const;
  inline void set_year(::google::protobuf::uint32 value);

  // optional uint32 month = 2;
  inline bool has_month() const;
  inline void clear_month();
  static const int kMonthFieldNumber = 2;
  inline ::google::protobuf::uint32 month() const;
  inline void set_month(::google::protobuf::uint32 value);

  // optional uint32 day = 3;
  inline bool has_day() const;
  inline void clear_day();
  static const int kDayFieldNumber = 3;
  inline ::google::protobuf::uint32 day() const;
  inline void set_day(::google::protobuf::uint32 value);

  // optional uint32 hour = 4;
  inline bool has_hour() const;
  inline void clear_hour();
  static const int kHourFieldNumber = 4;
  inline ::google::protobuf::uint32 hour() const;
  inline void set_hour(::google::protobuf::uint32 value);

  // optional uint32 minute = 5;
  inline bool has_minute() const;
  inline void clear_minute();
  static const int kMinuteFieldNumber = 5;
  inline ::google::protobuf::uint32 minute() const;
  inline void set_minute(::google::protobuf::uint32 value);

  // optional uint32 sec = 6;
  inline bool has_sec() const;
  inline void clear_sec();
  static const int kSecFieldNumber = 6;
  inline ::google::protobuf::uint32 sec() const;
  inline void set_sec(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DateTime.Date)
 private:
  inline void set_has_year();
  inline void clear_has_year();
  inline void set_has_month();
  inline void clear_has_month();
  inline void set_has_day();
  inline void clear_has_day();
  inline void set_has_hour();
  inline void clear_has_hour();
  inline void set_has_minute();
  inline void clear_has_minute();
  inline void set_has_sec();
  inline void clear_has_sec();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 year_;
  ::google::protobuf::uint32 month_;
  ::google::protobuf::uint32 day_;
  ::google::protobuf::uint32 hour_;
  ::google::protobuf::uint32 minute_;
  ::google::protobuf::uint32 sec_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_common_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_common_2eproto();
  #endif
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static DateTime_Date* default_instance_;
};
// -------------------------------------------------------------------

class DateTime : public ::google::protobuf::MessageLite {
 public:
  DateTime();
  virtual ~DateTime();

  DateTime(const DateTime& from);

  inline DateTime& operator=(const DateTime& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const DateTime& default_instance();

  enum DCase {
    kUnix = 1,
    kText = 2,
    kDate = 3,
    D_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DateTime* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DateTime* other);

  // implements Message ----------------------------------------------

  DateTime* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DateTime& from);
  void MergeFrom(const DateTime& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef DateTime_Unix Unix;
  typedef DateTime_Text Text;
  typedef DateTime_Date Date;

  // accessors -------------------------------------------------------

  // optional .DateTime.Unix unix = 1;
  inline bool has_unix() const;
  inline void clear_unix();
  static const int kUnixFieldNumber = 1;
  inline const ::DateTime_Unix& unix() const;
  inline ::DateTime_Unix* mutable_unix();
  inline ::DateTime_Unix* release_unix();
  inline void set_allocated_unix(::DateTime_Unix* unix);

  // optional .DateTime.Text text = 2;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 2;
  inline const ::DateTime_Text& text() const;
  inline ::DateTime_Text* mutable_text();
  inline ::DateTime_Text* release_text();
  inline void set_allocated_text(::DateTime_Text* text);

  // optional .DateTime.Date date = 3;
  inline bool has_date() const;
  inline void clear_date();
  static const int kDateFieldNumber = 3;
  inline const ::DateTime_Date& date() const;
  inline ::DateTime_Date* mutable_date();
  inline ::DateTime_Date* release_date();
  inline void set_allocated_date(::DateTime_Date* date);

  inline DCase d_case() const;
  // @@protoc_insertion_point(class_scope:DateTime)
 private:
  inline void set_has_unix();
  inline void set_has_text();
  inline void set_has_date();

  inline bool has_d();
  void clear_d();
  inline void clear_has_d();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union DUnion {
    ::DateTime_Unix* unix_;
    ::DateTime_Text* text_;
    ::DateTime_Date* date_;
  } d_;
  ::google::protobuf::uint32 _oneof_case_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_common_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_common_2eproto();
  #endif
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static DateTime* default_instance_;
};
// -------------------------------------------------------------------

class Event : public ::google::protobuf::MessageLite {
 public:
  Event();
  virtual ~Event();

  Event(const Event& from);

  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Event& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Event* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Event* other);

  // implements Message ----------------------------------------------

  Event* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Event& from);
  void MergeFrom(const Event& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed64 timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline ::google::protobuf::uint64 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Event)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 timestamp_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_common_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_common_2eproto();
  #endif
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static Event* default_instance_;
};
// -------------------------------------------------------------------

class TimeLine : public ::google::protobuf::MessageLite {
 public:
  TimeLine();
  virtual ~TimeLine();

  TimeLine(const TimeLine& from);

  inline TimeLine& operator=(const TimeLine& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const TimeLine& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TimeLine* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TimeLine* other);

  // implements Message ----------------------------------------------

  TimeLine* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TimeLine& from);
  void MergeFrom(const TimeLine& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Event event = 1;
  inline int event_size() const;
  inline void clear_event();
  static const int kEventFieldNumber = 1;
  inline const ::Event& event(int index) const;
  inline ::Event* mutable_event(int index);
  inline ::Event* add_event();
  inline const ::google::protobuf::RepeatedPtrField< ::Event >&
      event() const;
  inline ::google::protobuf::RepeatedPtrField< ::Event >*
      mutable_event();

  // @@protoc_insertion_point(class_scope:TimeLine)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Event > event_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_common_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_common_2eproto();
  #endif
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static TimeLine* default_instance_;
};
// ===================================================================


// ===================================================================

// ResponseCode

// optional bool error = 1;
inline bool ResponseCode::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseCode::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseCode::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseCode::clear_error() {
  error_ = false;
  clear_has_error();
}
inline bool ResponseCode::error() const {
  // @@protoc_insertion_point(field_get:ResponseCode.error)
  return error_;
}
inline void ResponseCode::set_error(bool value) {
  set_has_error();
  error_ = value;
  // @@protoc_insertion_point(field_set:ResponseCode.error)
}

// optional uint32 code = 2;
inline bool ResponseCode::has_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseCode::set_has_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseCode::clear_has_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseCode::clear_code() {
  code_ = 0u;
  clear_has_code();
}
inline ::google::protobuf::uint32 ResponseCode::code() const {
  // @@protoc_insertion_point(field_get:ResponseCode.code)
  return code_;
}
inline void ResponseCode::set_code(::google::protobuf::uint32 value) {
  set_has_code();
  code_ = value;
  // @@protoc_insertion_point(field_set:ResponseCode.code)
}

// -------------------------------------------------------------------

// Filter_FilterComponent

// required bytes lvalue = 1;
inline bool Filter_FilterComponent::has_lvalue() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Filter_FilterComponent::set_has_lvalue() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Filter_FilterComponent::clear_has_lvalue() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Filter_FilterComponent::clear_lvalue() {
  if (lvalue_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lvalue_->clear();
  }
  clear_has_lvalue();
}
inline const ::std::string& Filter_FilterComponent::lvalue() const {
  // @@protoc_insertion_point(field_get:Filter.FilterComponent.lvalue)
  return *lvalue_;
}
inline void Filter_FilterComponent::set_lvalue(const ::std::string& value) {
  set_has_lvalue();
  if (lvalue_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lvalue_ = new ::std::string;
  }
  lvalue_->assign(value);
  // @@protoc_insertion_point(field_set:Filter.FilterComponent.lvalue)
}
inline void Filter_FilterComponent::set_lvalue(const char* value) {
  set_has_lvalue();
  if (lvalue_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lvalue_ = new ::std::string;
  }
  lvalue_->assign(value);
  // @@protoc_insertion_point(field_set_char:Filter.FilterComponent.lvalue)
}
inline void Filter_FilterComponent::set_lvalue(const void* value, size_t size) {
  set_has_lvalue();
  if (lvalue_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lvalue_ = new ::std::string;
  }
  lvalue_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Filter.FilterComponent.lvalue)
}
inline ::std::string* Filter_FilterComponent::mutable_lvalue() {
  set_has_lvalue();
  if (lvalue_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lvalue_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Filter.FilterComponent.lvalue)
  return lvalue_;
}
inline ::std::string* Filter_FilterComponent::release_lvalue() {
  clear_has_lvalue();
  if (lvalue_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = lvalue_;
    lvalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Filter_FilterComponent::set_allocated_lvalue(::std::string* lvalue) {
  if (lvalue_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete lvalue_;
  }
  if (lvalue) {
    set_has_lvalue();
    lvalue_ = lvalue;
  } else {
    clear_has_lvalue();
    lvalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Filter.FilterComponent.lvalue)
}

// required .Filter.FilterComponent.Operation operation = 2;
inline bool Filter_FilterComponent::has_operation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Filter_FilterComponent::set_has_operation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Filter_FilterComponent::clear_has_operation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Filter_FilterComponent::clear_operation() {
  operation_ = 1;
  clear_has_operation();
}
inline ::Filter_FilterComponent_Operation Filter_FilterComponent::operation() const {
  // @@protoc_insertion_point(field_get:Filter.FilterComponent.operation)
  return static_cast< ::Filter_FilterComponent_Operation >(operation_);
}
inline void Filter_FilterComponent::set_operation(::Filter_FilterComponent_Operation value) {
  assert(::Filter_FilterComponent_Operation_IsValid(value));
  set_has_operation();
  operation_ = value;
  // @@protoc_insertion_point(field_set:Filter.FilterComponent.operation)
}

// required bytes rvalue = 3;
inline bool Filter_FilterComponent::has_rvalue() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Filter_FilterComponent::set_has_rvalue() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Filter_FilterComponent::clear_has_rvalue() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Filter_FilterComponent::clear_rvalue() {
  if (rvalue_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rvalue_->clear();
  }
  clear_has_rvalue();
}
inline const ::std::string& Filter_FilterComponent::rvalue() const {
  // @@protoc_insertion_point(field_get:Filter.FilterComponent.rvalue)
  return *rvalue_;
}
inline void Filter_FilterComponent::set_rvalue(const ::std::string& value) {
  set_has_rvalue();
  if (rvalue_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rvalue_ = new ::std::string;
  }
  rvalue_->assign(value);
  // @@protoc_insertion_point(field_set:Filter.FilterComponent.rvalue)
}
inline void Filter_FilterComponent::set_rvalue(const char* value) {
  set_has_rvalue();
  if (rvalue_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rvalue_ = new ::std::string;
  }
  rvalue_->assign(value);
  // @@protoc_insertion_point(field_set_char:Filter.FilterComponent.rvalue)
}
inline void Filter_FilterComponent::set_rvalue(const void* value, size_t size) {
  set_has_rvalue();
  if (rvalue_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rvalue_ = new ::std::string;
  }
  rvalue_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Filter.FilterComponent.rvalue)
}
inline ::std::string* Filter_FilterComponent::mutable_rvalue() {
  set_has_rvalue();
  if (rvalue_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rvalue_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Filter.FilterComponent.rvalue)
  return rvalue_;
}
inline ::std::string* Filter_FilterComponent::release_rvalue() {
  clear_has_rvalue();
  if (rvalue_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = rvalue_;
    rvalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Filter_FilterComponent::set_allocated_rvalue(::std::string* rvalue) {
  if (rvalue_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete rvalue_;
  }
  if (rvalue) {
    set_has_rvalue();
    rvalue_ = rvalue;
  } else {
    clear_has_rvalue();
    rvalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Filter.FilterComponent.rvalue)
}

// -------------------------------------------------------------------

// Filter

// repeated .Filter.FilterComponent component = 1;
inline int Filter::component_size() const {
  return component_.size();
}
inline void Filter::clear_component() {
  component_.Clear();
}
inline const ::Filter_FilterComponent& Filter::component(int index) const {
  // @@protoc_insertion_point(field_get:Filter.component)
  return component_.Get(index);
}
inline ::Filter_FilterComponent* Filter::mutable_component(int index) {
  // @@protoc_insertion_point(field_mutable:Filter.component)
  return component_.Mutable(index);
}
inline ::Filter_FilterComponent* Filter::add_component() {
  // @@protoc_insertion_point(field_add:Filter.component)
  return component_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Filter_FilterComponent >&
Filter::component() const {
  // @@protoc_insertion_point(field_list:Filter.component)
  return component_;
}
inline ::google::protobuf::RepeatedPtrField< ::Filter_FilterComponent >*
Filter::mutable_component() {
  // @@protoc_insertion_point(field_mutable_list:Filter.component)
  return &component_;
}

// -------------------------------------------------------------------

// Limits

// required uint32 count = 1;
inline bool Limits::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Limits::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Limits::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Limits::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 Limits::count() const {
  // @@protoc_insertion_point(field_get:Limits.count)
  return count_;
}
inline void Limits::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:Limits.count)
}

// required uint32 offset = 2;
inline bool Limits::has_offset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Limits::set_has_offset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Limits::clear_has_offset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Limits::clear_offset() {
  offset_ = 0u;
  clear_has_offset();
}
inline ::google::protobuf::uint32 Limits::offset() const {
  // @@protoc_insertion_point(field_get:Limits.offset)
  return offset_;
}
inline void Limits::set_offset(::google::protobuf::uint32 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:Limits.offset)
}

// -------------------------------------------------------------------

// OrderBy

// -------------------------------------------------------------------

// DateTime_Unix

// required fixed64 d = 1;
inline bool DateTime_Unix::has_d() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DateTime_Unix::set_has_d() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DateTime_Unix::clear_has_d() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DateTime_Unix::clear_d() {
  d_ = GOOGLE_ULONGLONG(0);
  clear_has_d();
}
inline ::google::protobuf::uint64 DateTime_Unix::d() const {
  // @@protoc_insertion_point(field_get:DateTime.Unix.d)
  return d_;
}
inline void DateTime_Unix::set_d(::google::protobuf::uint64 value) {
  set_has_d();
  d_ = value;
  // @@protoc_insertion_point(field_set:DateTime.Unix.d)
}

// -------------------------------------------------------------------

// DateTime_Text

// required string date_string = 1;
inline bool DateTime_Text::has_date_string() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DateTime_Text::set_has_date_string() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DateTime_Text::clear_has_date_string() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DateTime_Text::clear_date_string() {
  if (date_string_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_string_->clear();
  }
  clear_has_date_string();
}
inline const ::std::string& DateTime_Text::date_string() const {
  // @@protoc_insertion_point(field_get:DateTime.Text.date_string)
  return *date_string_;
}
inline void DateTime_Text::set_date_string(const ::std::string& value) {
  set_has_date_string();
  if (date_string_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_string_ = new ::std::string;
  }
  date_string_->assign(value);
  // @@protoc_insertion_point(field_set:DateTime.Text.date_string)
}
inline void DateTime_Text::set_date_string(const char* value) {
  set_has_date_string();
  if (date_string_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_string_ = new ::std::string;
  }
  date_string_->assign(value);
  // @@protoc_insertion_point(field_set_char:DateTime.Text.date_string)
}
inline void DateTime_Text::set_date_string(const char* value, size_t size) {
  set_has_date_string();
  if (date_string_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_string_ = new ::std::string;
  }
  date_string_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DateTime.Text.date_string)
}
inline ::std::string* DateTime_Text::mutable_date_string() {
  set_has_date_string();
  if (date_string_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_string_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DateTime.Text.date_string)
  return date_string_;
}
inline ::std::string* DateTime_Text::release_date_string() {
  clear_has_date_string();
  if (date_string_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = date_string_;
    date_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DateTime_Text::set_allocated_date_string(::std::string* date_string) {
  if (date_string_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete date_string_;
  }
  if (date_string) {
    set_has_date_string();
    date_string_ = date_string;
  } else {
    clear_has_date_string();
    date_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DateTime.Text.date_string)
}

// -------------------------------------------------------------------

// DateTime_Date

// optional uint32 year = 1;
inline bool DateTime_Date::has_year() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DateTime_Date::set_has_year() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DateTime_Date::clear_has_year() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DateTime_Date::clear_year() {
  year_ = 0u;
  clear_has_year();
}
inline ::google::protobuf::uint32 DateTime_Date::year() const {
  // @@protoc_insertion_point(field_get:DateTime.Date.year)
  return year_;
}
inline void DateTime_Date::set_year(::google::protobuf::uint32 value) {
  set_has_year();
  year_ = value;
  // @@protoc_insertion_point(field_set:DateTime.Date.year)
}

// optional uint32 month = 2;
inline bool DateTime_Date::has_month() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DateTime_Date::set_has_month() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DateTime_Date::clear_has_month() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DateTime_Date::clear_month() {
  month_ = 0u;
  clear_has_month();
}
inline ::google::protobuf::uint32 DateTime_Date::month() const {
  // @@protoc_insertion_point(field_get:DateTime.Date.month)
  return month_;
}
inline void DateTime_Date::set_month(::google::protobuf::uint32 value) {
  set_has_month();
  month_ = value;
  // @@protoc_insertion_point(field_set:DateTime.Date.month)
}

// optional uint32 day = 3;
inline bool DateTime_Date::has_day() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DateTime_Date::set_has_day() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DateTime_Date::clear_has_day() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DateTime_Date::clear_day() {
  day_ = 0u;
  clear_has_day();
}
inline ::google::protobuf::uint32 DateTime_Date::day() const {
  // @@protoc_insertion_point(field_get:DateTime.Date.day)
  return day_;
}
inline void DateTime_Date::set_day(::google::protobuf::uint32 value) {
  set_has_day();
  day_ = value;
  // @@protoc_insertion_point(field_set:DateTime.Date.day)
}

// optional uint32 hour = 4;
inline bool DateTime_Date::has_hour() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DateTime_Date::set_has_hour() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DateTime_Date::clear_has_hour() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DateTime_Date::clear_hour() {
  hour_ = 0u;
  clear_has_hour();
}
inline ::google::protobuf::uint32 DateTime_Date::hour() const {
  // @@protoc_insertion_point(field_get:DateTime.Date.hour)
  return hour_;
}
inline void DateTime_Date::set_hour(::google::protobuf::uint32 value) {
  set_has_hour();
  hour_ = value;
  // @@protoc_insertion_point(field_set:DateTime.Date.hour)
}

// optional uint32 minute = 5;
inline bool DateTime_Date::has_minute() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DateTime_Date::set_has_minute() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DateTime_Date::clear_has_minute() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DateTime_Date::clear_minute() {
  minute_ = 0u;
  clear_has_minute();
}
inline ::google::protobuf::uint32 DateTime_Date::minute() const {
  // @@protoc_insertion_point(field_get:DateTime.Date.minute)
  return minute_;
}
inline void DateTime_Date::set_minute(::google::protobuf::uint32 value) {
  set_has_minute();
  minute_ = value;
  // @@protoc_insertion_point(field_set:DateTime.Date.minute)
}

// optional uint32 sec = 6;
inline bool DateTime_Date::has_sec() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DateTime_Date::set_has_sec() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DateTime_Date::clear_has_sec() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DateTime_Date::clear_sec() {
  sec_ = 0u;
  clear_has_sec();
}
inline ::google::protobuf::uint32 DateTime_Date::sec() const {
  // @@protoc_insertion_point(field_get:DateTime.Date.sec)
  return sec_;
}
inline void DateTime_Date::set_sec(::google::protobuf::uint32 value) {
  set_has_sec();
  sec_ = value;
  // @@protoc_insertion_point(field_set:DateTime.Date.sec)
}

// -------------------------------------------------------------------

// DateTime

// optional .DateTime.Unix unix = 1;
inline bool DateTime::has_unix() const {
  return d_case() == kUnix;
}
inline void DateTime::set_has_unix() {
  _oneof_case_[0] = kUnix;
}
inline void DateTime::clear_unix() {
  if (has_unix()) {
    delete d_.unix_;
    clear_has_d();
  }
}
inline const ::DateTime_Unix& DateTime::unix() const {
  return has_unix() ? *d_.unix_
                      : ::DateTime_Unix::default_instance();
}
inline ::DateTime_Unix* DateTime::mutable_unix() {
  if (!has_unix()) {
    clear_d();
    set_has_unix();
    d_.unix_ = new ::DateTime_Unix;
  }
  return d_.unix_;
}
inline ::DateTime_Unix* DateTime::release_unix() {
  if (has_unix()) {
    clear_has_d();
    ::DateTime_Unix* temp = d_.unix_;
    d_.unix_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void DateTime::set_allocated_unix(::DateTime_Unix* unix) {
  clear_d();
  if (unix) {
    set_has_unix();
    d_.unix_ = unix;
  }
}

// optional .DateTime.Text text = 2;
inline bool DateTime::has_text() const {
  return d_case() == kText;
}
inline void DateTime::set_has_text() {
  _oneof_case_[0] = kText;
}
inline void DateTime::clear_text() {
  if (has_text()) {
    delete d_.text_;
    clear_has_d();
  }
}
inline const ::DateTime_Text& DateTime::text() const {
  return has_text() ? *d_.text_
                      : ::DateTime_Text::default_instance();
}
inline ::DateTime_Text* DateTime::mutable_text() {
  if (!has_text()) {
    clear_d();
    set_has_text();
    d_.text_ = new ::DateTime_Text;
  }
  return d_.text_;
}
inline ::DateTime_Text* DateTime::release_text() {
  if (has_text()) {
    clear_has_d();
    ::DateTime_Text* temp = d_.text_;
    d_.text_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void DateTime::set_allocated_text(::DateTime_Text* text) {
  clear_d();
  if (text) {
    set_has_text();
    d_.text_ = text;
  }
}

// optional .DateTime.Date date = 3;
inline bool DateTime::has_date() const {
  return d_case() == kDate;
}
inline void DateTime::set_has_date() {
  _oneof_case_[0] = kDate;
}
inline void DateTime::clear_date() {
  if (has_date()) {
    delete d_.date_;
    clear_has_d();
  }
}
inline const ::DateTime_Date& DateTime::date() const {
  return has_date() ? *d_.date_
                      : ::DateTime_Date::default_instance();
}
inline ::DateTime_Date* DateTime::mutable_date() {
  if (!has_date()) {
    clear_d();
    set_has_date();
    d_.date_ = new ::DateTime_Date;
  }
  return d_.date_;
}
inline ::DateTime_Date* DateTime::release_date() {
  if (has_date()) {
    clear_has_d();
    ::DateTime_Date* temp = d_.date_;
    d_.date_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void DateTime::set_allocated_date(::DateTime_Date* date) {
  clear_d();
  if (date) {
    set_has_date();
    d_.date_ = date;
  }
}

inline bool DateTime::has_d() {
  return d_case() != D_NOT_SET;
}
inline void DateTime::clear_has_d() {
  _oneof_case_[0] = D_NOT_SET;
}
inline DateTime::DCase DateTime::d_case() const {
  return DateTime::DCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Event

// required fixed64 timestamp = 1;
inline bool Event::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Event::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Event::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Event::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 Event::timestamp() const {
  // @@protoc_insertion_point(field_get:Event.timestamp)
  return timestamp_;
}
inline void Event::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:Event.timestamp)
}

// -------------------------------------------------------------------

// TimeLine

// repeated .Event event = 1;
inline int TimeLine::event_size() const {
  return event_.size();
}
inline void TimeLine::clear_event() {
  event_.Clear();
}
inline const ::Event& TimeLine::event(int index) const {
  // @@protoc_insertion_point(field_get:TimeLine.event)
  return event_.Get(index);
}
inline ::Event* TimeLine::mutable_event(int index) {
  // @@protoc_insertion_point(field_mutable:TimeLine.event)
  return event_.Mutable(index);
}
inline ::Event* TimeLine::add_event() {
  // @@protoc_insertion_point(field_add:TimeLine.event)
  return event_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Event >&
TimeLine::event() const {
  // @@protoc_insertion_point(field_list:TimeLine.event)
  return event_;
}
inline ::google::protobuf::RepeatedPtrField< ::Event >*
TimeLine::mutable_event() {
  // @@protoc_insertion_point(field_mutable_list:TimeLine.event)
  return &event_;
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_common_2eproto__INCLUDED
