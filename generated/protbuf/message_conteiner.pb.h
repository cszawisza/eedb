// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message_conteiner.proto

#ifndef PROTOBUF_message_5fconteiner_2eproto__INCLUDED
#define PROTOBUF_message_5fconteiner_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "types.pb.h"
#include "group.pb.h"
#include "user.pb.h"
#include "package.pb.h"
#include "parameters.pb.h"
#include "item.pb.h"
// @@protoc_insertion_point(includes)

namespace protbuf {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_message_5fconteiner_2eproto();
void protobuf_AssignDesc_message_5fconteiner_2eproto();
void protobuf_ShutdownFile_message_5fconteiner_2eproto();

class MessageFrame;
class ResponseCode;
class FilterComponent;
class Filter;
class Limits;
class OrderBy;
class MessageCapsule;

enum FilterComponent_Operation {
  FilterComponent_Operation_Equal = 1,
  FilterComponent_Operation_NotEqual = 2,
  FilterComponent_Operation_LessThen = 3
};
bool FilterComponent_Operation_IsValid(int value);
const FilterComponent_Operation FilterComponent_Operation_Operation_MIN = FilterComponent_Operation_Equal;
const FilterComponent_Operation FilterComponent_Operation_Operation_MAX = FilterComponent_Operation_LessThen;
const int FilterComponent_Operation_Operation_ARRAYSIZE = FilterComponent_Operation_Operation_MAX + 1;

enum Action {
  Select = 1,
  Get = 1,
  Insert = 2,
  Add = 2,
  Update = 3,
  Set = 3,
  Delete = 4,
  Remove = 4,
  InsertOrUpdate = 5,
  ServerResponse = 16
};
bool Action_IsValid(int value);
const Action Action_MIN = Select;
const Action Action_MAX = ServerResponse;
const int Action_ARRAYSIZE = Action_MAX + 1;

// ===================================================================

class MessageFrame : public ::google::protobuf::MessageLite {
 public:
  MessageFrame();
  virtual ~MessageFrame();

  MessageFrame(const MessageFrame& from);

  inline MessageFrame& operator=(const MessageFrame& from) {
    CopyFrom(from);
    return *this;
  }

  static const MessageFrame& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MessageFrame* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MessageFrame* other);

  // implements Message ----------------------------------------------

  MessageFrame* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MessageFrame& from);
  void MergeFrom(const MessageFrame& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protbuf.MessageCapsule capsules = 1;
  inline int capsules_size() const;
  inline void clear_capsules();
  static const int kCapsulesFieldNumber = 1;
  inline const ::protbuf::MessageCapsule& capsules(int index) const;
  inline ::protbuf::MessageCapsule* mutable_capsules(int index);
  inline ::protbuf::MessageCapsule* add_capsules();
  inline const ::google::protobuf::RepeatedPtrField< ::protbuf::MessageCapsule >&
      capsules() const;
  inline ::google::protobuf::RepeatedPtrField< ::protbuf::MessageCapsule >*
      mutable_capsules();

  // @@protoc_insertion_point(class_scope:protbuf.MessageFrame)
 private:

  ::google::protobuf::RepeatedPtrField< ::protbuf::MessageCapsule > capsules_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_5fconteiner_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_5fconteiner_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_5fconteiner_2eproto();
  friend void protobuf_ShutdownFile_message_5fconteiner_2eproto();

  void InitAsDefaultInstance();
  static MessageFrame* default_instance_;
};
// -------------------------------------------------------------------

class ResponseCode : public ::google::protobuf::MessageLite {
 public:
  ResponseCode();
  virtual ~ResponseCode();

  ResponseCode(const ResponseCode& from);

  inline ResponseCode& operator=(const ResponseCode& from) {
    CopyFrom(from);
    return *this;
  }

  static const ResponseCode& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResponseCode* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ResponseCode* other);

  // implements Message ----------------------------------------------

  ResponseCode* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResponseCode& from);
  void MergeFrom(const ResponseCode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline bool error() const;
  inline void set_error(bool value);

  // repeated uint32 code = 2;
  inline int code_size() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 code(int index) const;
  inline void set_code(int index, ::google::protobuf::uint32 value);
  inline void add_code(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      code() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_code();

  // @@protoc_insertion_point(class_scope:protbuf.ResponseCode)
 private:
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > code_;
  bool error_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_5fconteiner_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_5fconteiner_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_5fconteiner_2eproto();
  friend void protobuf_ShutdownFile_message_5fconteiner_2eproto();

  void InitAsDefaultInstance();
  static ResponseCode* default_instance_;
};
// -------------------------------------------------------------------

class FilterComponent : public ::google::protobuf::MessageLite {
 public:
  FilterComponent();
  virtual ~FilterComponent();

  FilterComponent(const FilterComponent& from);

  inline FilterComponent& operator=(const FilterComponent& from) {
    CopyFrom(from);
    return *this;
  }

  static const FilterComponent& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FilterComponent* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FilterComponent* other);

  // implements Message ----------------------------------------------

  FilterComponent* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FilterComponent& from);
  void MergeFrom(const FilterComponent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef FilterComponent_Operation Operation;
  static const Operation Equal = FilterComponent_Operation_Equal;
  static const Operation NotEqual = FilterComponent_Operation_NotEqual;
  static const Operation LessThen = FilterComponent_Operation_LessThen;
  static inline bool Operation_IsValid(int value) {
    return FilterComponent_Operation_IsValid(value);
  }
  static const Operation Operation_MIN =
    FilterComponent_Operation_Operation_MIN;
  static const Operation Operation_MAX =
    FilterComponent_Operation_Operation_MAX;
  static const int Operation_ARRAYSIZE =
    FilterComponent_Operation_Operation_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required bytes lvalue = 1;
  inline bool has_lvalue() const;
  inline void clear_lvalue();
  static const int kLvalueFieldNumber = 1;
  inline const ::std::string& lvalue() const;
  inline void set_lvalue(const ::std::string& value);
  inline void set_lvalue(const char* value);
  inline void set_lvalue(const void* value, size_t size);
  inline ::std::string* mutable_lvalue();
  inline ::std::string* release_lvalue();
  inline void set_allocated_lvalue(::std::string* lvalue);

  // required .protbuf.FilterComponent.Operation operation = 2;
  inline bool has_operation() const;
  inline void clear_operation();
  static const int kOperationFieldNumber = 2;
  inline ::protbuf::FilterComponent_Operation operation() const;
  inline void set_operation(::protbuf::FilterComponent_Operation value);

  // required bytes rvalue = 3;
  inline bool has_rvalue() const;
  inline void clear_rvalue();
  static const int kRvalueFieldNumber = 3;
  inline const ::std::string& rvalue() const;
  inline void set_rvalue(const ::std::string& value);
  inline void set_rvalue(const char* value);
  inline void set_rvalue(const void* value, size_t size);
  inline ::std::string* mutable_rvalue();
  inline ::std::string* release_rvalue();
  inline void set_allocated_rvalue(::std::string* rvalue);

  // @@protoc_insertion_point(class_scope:protbuf.FilterComponent)
 private:
  inline void set_has_lvalue();
  inline void clear_has_lvalue();
  inline void set_has_operation();
  inline void clear_has_operation();
  inline void set_has_rvalue();
  inline void clear_has_rvalue();

  ::std::string* lvalue_;
  ::std::string* rvalue_;
  int operation_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_5fconteiner_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_5fconteiner_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_5fconteiner_2eproto();
  friend void protobuf_ShutdownFile_message_5fconteiner_2eproto();

  void InitAsDefaultInstance();
  static FilterComponent* default_instance_;
};
// -------------------------------------------------------------------

class Filter : public ::google::protobuf::MessageLite {
 public:
  Filter();
  virtual ~Filter();

  Filter(const Filter& from);

  inline Filter& operator=(const Filter& from) {
    CopyFrom(from);
    return *this;
  }

  static const Filter& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Filter* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Filter* other);

  // implements Message ----------------------------------------------

  Filter* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Filter& from);
  void MergeFrom(const Filter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protbuf.FilterComponent component = 1;
  inline int component_size() const;
  inline void clear_component();
  static const int kComponentFieldNumber = 1;
  inline const ::protbuf::FilterComponent& component(int index) const;
  inline ::protbuf::FilterComponent* mutable_component(int index);
  inline ::protbuf::FilterComponent* add_component();
  inline const ::google::protobuf::RepeatedPtrField< ::protbuf::FilterComponent >&
      component() const;
  inline ::google::protobuf::RepeatedPtrField< ::protbuf::FilterComponent >*
      mutable_component();

  // @@protoc_insertion_point(class_scope:protbuf.Filter)
 private:

  ::google::protobuf::RepeatedPtrField< ::protbuf::FilterComponent > component_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_5fconteiner_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_5fconteiner_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_5fconteiner_2eproto();
  friend void protobuf_ShutdownFile_message_5fconteiner_2eproto();

  void InitAsDefaultInstance();
  static Filter* default_instance_;
};
// -------------------------------------------------------------------

class Limits : public ::google::protobuf::MessageLite {
 public:
  Limits();
  virtual ~Limits();

  Limits(const Limits& from);

  inline Limits& operator=(const Limits& from) {
    CopyFrom(from);
    return *this;
  }

  static const Limits& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Limits* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Limits* other);

  // implements Message ----------------------------------------------

  Limits* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Limits& from);
  void MergeFrom(const Limits& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 count = 1;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 1;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // required uint32 offset = 2;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 2;
  inline ::google::protobuf::uint32 offset() const;
  inline void set_offset(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protbuf.Limits)
 private:
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_offset();
  inline void clear_has_offset();

  ::google::protobuf::uint32 count_;
  ::google::protobuf::uint32 offset_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_5fconteiner_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_5fconteiner_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_5fconteiner_2eproto();
  friend void protobuf_ShutdownFile_message_5fconteiner_2eproto();

  void InitAsDefaultInstance();
  static Limits* default_instance_;
};
// -------------------------------------------------------------------

class OrderBy : public ::google::protobuf::MessageLite {
 public:
  OrderBy();
  virtual ~OrderBy();

  OrderBy(const OrderBy& from);

  inline OrderBy& operator=(const OrderBy& from) {
    CopyFrom(from);
    return *this;
  }

  static const OrderBy& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const OrderBy* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(OrderBy* other);

  // implements Message ----------------------------------------------

  OrderBy* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const OrderBy& from);
  void MergeFrom(const OrderBy& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protbuf.OrderBy)
 private:


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_5fconteiner_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_5fconteiner_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_5fconteiner_2eproto();
  friend void protobuf_ShutdownFile_message_5fconteiner_2eproto();

  void InitAsDefaultInstance();
  static OrderBy* default_instance_;
};
// -------------------------------------------------------------------

class MessageCapsule : public ::google::protobuf::MessageLite {
 public:
  MessageCapsule();
  virtual ~MessageCapsule();

  MessageCapsule(const MessageCapsule& from);

  inline MessageCapsule& operator=(const MessageCapsule& from) {
    CopyFrom(from);
    return *this;
  }

  static const MessageCapsule& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MessageCapsule* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MessageCapsule* other);

  // implements Message ----------------------------------------------

  MessageCapsule* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MessageCapsule& from);
  void MergeFrom(const MessageCapsule& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 msgId = 1 [default = 1];
  inline bool has_msgid() const;
  inline void clear_msgid();
  static const int kMsgIdFieldNumber = 1;
  inline ::google::protobuf::uint32 msgid() const;
  inline void set_msgid(::google::protobuf::uint32 value);

  // required .MsgType msgType = 2;
  inline bool has_msgtype() const;
  inline void clear_msgtype();
  static const int kMsgTypeFieldNumber = 2;
  inline ::MsgType msgtype() const;
  inline void set_msgtype(::MsgType value);

  // optional bytes data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // optional .protbuf.Action action = 4;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 4;
  inline ::protbuf::Action action() const;
  inline void set_action(::protbuf::Action value);

  // optional .protbuf.Filter filter = 5;
  inline bool has_filter() const;
  inline void clear_filter();
  static const int kFilterFieldNumber = 5;
  inline const ::protbuf::Filter& filter() const;
  inline ::protbuf::Filter* mutable_filter();
  inline ::protbuf::Filter* release_filter();
  inline void set_allocated_filter(::protbuf::Filter* filter);

  // optional .protbuf.Limits limits = 6;
  inline bool has_limits() const;
  inline void clear_limits();
  static const int kLimitsFieldNumber = 6;
  inline const ::protbuf::Limits& limits() const;
  inline ::protbuf::Limits* mutable_limits();
  inline ::protbuf::Limits* release_limits();
  inline void set_allocated_limits(::protbuf::Limits* limits);

  // optional .protbuf.OrderBy order = 7;
  inline bool has_order() const;
  inline void clear_order();
  static const int kOrderFieldNumber = 7;
  inline const ::protbuf::OrderBy& order() const;
  inline ::protbuf::OrderBy* mutable_order();
  inline ::protbuf::OrderBy* release_order();
  inline void set_allocated_order(::protbuf::OrderBy* order);

  // optional bool compressed = 8;
  inline bool has_compressed() const;
  inline void clear_compressed();
  static const int kCompressedFieldNumber = 8;
  inline bool compressed() const;
  inline void set_compressed(bool value);

  // @@protoc_insertion_point(class_scope:protbuf.MessageCapsule)
 private:
  inline void set_has_msgid();
  inline void clear_has_msgid();
  inline void set_has_msgtype();
  inline void clear_has_msgtype();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_action();
  inline void clear_has_action();
  inline void set_has_filter();
  inline void clear_has_filter();
  inline void set_has_limits();
  inline void clear_has_limits();
  inline void set_has_order();
  inline void clear_has_order();
  inline void set_has_compressed();
  inline void clear_has_compressed();

  ::google::protobuf::uint32 msgid_;
  int msgtype_;
  ::std::string* data_;
  ::protbuf::Filter* filter_;
  ::protbuf::Limits* limits_;
  int action_;
  bool compressed_;
  ::protbuf::OrderBy* order_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_5fconteiner_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_5fconteiner_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_5fconteiner_2eproto();
  friend void protobuf_ShutdownFile_message_5fconteiner_2eproto();

  void InitAsDefaultInstance();
  static MessageCapsule* default_instance_;
};
// ===================================================================


// ===================================================================

// MessageFrame

// repeated .protbuf.MessageCapsule capsules = 1;
inline int MessageFrame::capsules_size() const {
  return capsules_.size();
}
inline void MessageFrame::clear_capsules() {
  capsules_.Clear();
}
inline const ::protbuf::MessageCapsule& MessageFrame::capsules(int index) const {
  return capsules_.Get(index);
}
inline ::protbuf::MessageCapsule* MessageFrame::mutable_capsules(int index) {
  return capsules_.Mutable(index);
}
inline ::protbuf::MessageCapsule* MessageFrame::add_capsules() {
  return capsules_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protbuf::MessageCapsule >&
MessageFrame::capsules() const {
  return capsules_;
}
inline ::google::protobuf::RepeatedPtrField< ::protbuf::MessageCapsule >*
MessageFrame::mutable_capsules() {
  return &capsules_;
}

// -------------------------------------------------------------------

// ResponseCode

// required bool error = 1;
inline bool ResponseCode::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseCode::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseCode::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseCode::clear_error() {
  error_ = false;
  clear_has_error();
}
inline bool ResponseCode::error() const {
  return error_;
}
inline void ResponseCode::set_error(bool value) {
  set_has_error();
  error_ = value;
}

// repeated uint32 code = 2;
inline int ResponseCode::code_size() const {
  return code_.size();
}
inline void ResponseCode::clear_code() {
  code_.Clear();
}
inline ::google::protobuf::uint32 ResponseCode::code(int index) const {
  return code_.Get(index);
}
inline void ResponseCode::set_code(int index, ::google::protobuf::uint32 value) {
  code_.Set(index, value);
}
inline void ResponseCode::add_code(::google::protobuf::uint32 value) {
  code_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ResponseCode::code() const {
  return code_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ResponseCode::mutable_code() {
  return &code_;
}

// -------------------------------------------------------------------

// FilterComponent

// required bytes lvalue = 1;
inline bool FilterComponent::has_lvalue() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FilterComponent::set_has_lvalue() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FilterComponent::clear_has_lvalue() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FilterComponent::clear_lvalue() {
  if (lvalue_ != &::google::protobuf::internal::kEmptyString) {
    lvalue_->clear();
  }
  clear_has_lvalue();
}
inline const ::std::string& FilterComponent::lvalue() const {
  return *lvalue_;
}
inline void FilterComponent::set_lvalue(const ::std::string& value) {
  set_has_lvalue();
  if (lvalue_ == &::google::protobuf::internal::kEmptyString) {
    lvalue_ = new ::std::string;
  }
  lvalue_->assign(value);
}
inline void FilterComponent::set_lvalue(const char* value) {
  set_has_lvalue();
  if (lvalue_ == &::google::protobuf::internal::kEmptyString) {
    lvalue_ = new ::std::string;
  }
  lvalue_->assign(value);
}
inline void FilterComponent::set_lvalue(const void* value, size_t size) {
  set_has_lvalue();
  if (lvalue_ == &::google::protobuf::internal::kEmptyString) {
    lvalue_ = new ::std::string;
  }
  lvalue_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FilterComponent::mutable_lvalue() {
  set_has_lvalue();
  if (lvalue_ == &::google::protobuf::internal::kEmptyString) {
    lvalue_ = new ::std::string;
  }
  return lvalue_;
}
inline ::std::string* FilterComponent::release_lvalue() {
  clear_has_lvalue();
  if (lvalue_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = lvalue_;
    lvalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FilterComponent::set_allocated_lvalue(::std::string* lvalue) {
  if (lvalue_ != &::google::protobuf::internal::kEmptyString) {
    delete lvalue_;
  }
  if (lvalue) {
    set_has_lvalue();
    lvalue_ = lvalue;
  } else {
    clear_has_lvalue();
    lvalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .protbuf.FilterComponent.Operation operation = 2;
inline bool FilterComponent::has_operation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FilterComponent::set_has_operation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FilterComponent::clear_has_operation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FilterComponent::clear_operation() {
  operation_ = 1;
  clear_has_operation();
}
inline ::protbuf::FilterComponent_Operation FilterComponent::operation() const {
  return static_cast< ::protbuf::FilterComponent_Operation >(operation_);
}
inline void FilterComponent::set_operation(::protbuf::FilterComponent_Operation value) {
  assert(::protbuf::FilterComponent_Operation_IsValid(value));
  set_has_operation();
  operation_ = value;
}

// required bytes rvalue = 3;
inline bool FilterComponent::has_rvalue() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FilterComponent::set_has_rvalue() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FilterComponent::clear_has_rvalue() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FilterComponent::clear_rvalue() {
  if (rvalue_ != &::google::protobuf::internal::kEmptyString) {
    rvalue_->clear();
  }
  clear_has_rvalue();
}
inline const ::std::string& FilterComponent::rvalue() const {
  return *rvalue_;
}
inline void FilterComponent::set_rvalue(const ::std::string& value) {
  set_has_rvalue();
  if (rvalue_ == &::google::protobuf::internal::kEmptyString) {
    rvalue_ = new ::std::string;
  }
  rvalue_->assign(value);
}
inline void FilterComponent::set_rvalue(const char* value) {
  set_has_rvalue();
  if (rvalue_ == &::google::protobuf::internal::kEmptyString) {
    rvalue_ = new ::std::string;
  }
  rvalue_->assign(value);
}
inline void FilterComponent::set_rvalue(const void* value, size_t size) {
  set_has_rvalue();
  if (rvalue_ == &::google::protobuf::internal::kEmptyString) {
    rvalue_ = new ::std::string;
  }
  rvalue_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FilterComponent::mutable_rvalue() {
  set_has_rvalue();
  if (rvalue_ == &::google::protobuf::internal::kEmptyString) {
    rvalue_ = new ::std::string;
  }
  return rvalue_;
}
inline ::std::string* FilterComponent::release_rvalue() {
  clear_has_rvalue();
  if (rvalue_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rvalue_;
    rvalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FilterComponent::set_allocated_rvalue(::std::string* rvalue) {
  if (rvalue_ != &::google::protobuf::internal::kEmptyString) {
    delete rvalue_;
  }
  if (rvalue) {
    set_has_rvalue();
    rvalue_ = rvalue;
  } else {
    clear_has_rvalue();
    rvalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Filter

// repeated .protbuf.FilterComponent component = 1;
inline int Filter::component_size() const {
  return component_.size();
}
inline void Filter::clear_component() {
  component_.Clear();
}
inline const ::protbuf::FilterComponent& Filter::component(int index) const {
  return component_.Get(index);
}
inline ::protbuf::FilterComponent* Filter::mutable_component(int index) {
  return component_.Mutable(index);
}
inline ::protbuf::FilterComponent* Filter::add_component() {
  return component_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protbuf::FilterComponent >&
Filter::component() const {
  return component_;
}
inline ::google::protobuf::RepeatedPtrField< ::protbuf::FilterComponent >*
Filter::mutable_component() {
  return &component_;
}

// -------------------------------------------------------------------

// Limits

// required uint32 count = 1;
inline bool Limits::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Limits::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Limits::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Limits::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 Limits::count() const {
  return count_;
}
inline void Limits::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// required uint32 offset = 2;
inline bool Limits::has_offset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Limits::set_has_offset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Limits::clear_has_offset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Limits::clear_offset() {
  offset_ = 0u;
  clear_has_offset();
}
inline ::google::protobuf::uint32 Limits::offset() const {
  return offset_;
}
inline void Limits::set_offset(::google::protobuf::uint32 value) {
  set_has_offset();
  offset_ = value;
}

// -------------------------------------------------------------------

// OrderBy

// -------------------------------------------------------------------

// MessageCapsule

// required uint32 msgId = 1 [default = 1];
inline bool MessageCapsule::has_msgid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageCapsule::set_has_msgid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessageCapsule::clear_has_msgid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessageCapsule::clear_msgid() {
  msgid_ = 1u;
  clear_has_msgid();
}
inline ::google::protobuf::uint32 MessageCapsule::msgid() const {
  return msgid_;
}
inline void MessageCapsule::set_msgid(::google::protobuf::uint32 value) {
  set_has_msgid();
  msgid_ = value;
}

// required .MsgType msgType = 2;
inline bool MessageCapsule::has_msgtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MessageCapsule::set_has_msgtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MessageCapsule::clear_has_msgtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MessageCapsule::clear_msgtype() {
  msgtype_ = 0;
  clear_has_msgtype();
}
inline ::MsgType MessageCapsule::msgtype() const {
  return static_cast< ::MsgType >(msgtype_);
}
inline void MessageCapsule::set_msgtype(::MsgType value) {
  assert(::MsgType_IsValid(value));
  set_has_msgtype();
  msgtype_ = value;
}

// optional bytes data = 3;
inline bool MessageCapsule::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MessageCapsule::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MessageCapsule::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MessageCapsule::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& MessageCapsule::data() const {
  return *data_;
}
inline void MessageCapsule::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void MessageCapsule::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void MessageCapsule::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessageCapsule::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* MessageCapsule::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MessageCapsule::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .protbuf.Action action = 4;
inline bool MessageCapsule::has_action() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MessageCapsule::set_has_action() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MessageCapsule::clear_has_action() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MessageCapsule::clear_action() {
  action_ = 1;
  clear_has_action();
}
inline ::protbuf::Action MessageCapsule::action() const {
  return static_cast< ::protbuf::Action >(action_);
}
inline void MessageCapsule::set_action(::protbuf::Action value) {
  assert(::protbuf::Action_IsValid(value));
  set_has_action();
  action_ = value;
}

// optional .protbuf.Filter filter = 5;
inline bool MessageCapsule::has_filter() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MessageCapsule::set_has_filter() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MessageCapsule::clear_has_filter() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MessageCapsule::clear_filter() {
  if (filter_ != NULL) filter_->::protbuf::Filter::Clear();
  clear_has_filter();
}
inline const ::protbuf::Filter& MessageCapsule::filter() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return filter_ != NULL ? *filter_ : *default_instance().filter_;
#else
  return filter_ != NULL ? *filter_ : *default_instance_->filter_;
#endif
}
inline ::protbuf::Filter* MessageCapsule::mutable_filter() {
  set_has_filter();
  if (filter_ == NULL) filter_ = new ::protbuf::Filter;
  return filter_;
}
inline ::protbuf::Filter* MessageCapsule::release_filter() {
  clear_has_filter();
  ::protbuf::Filter* temp = filter_;
  filter_ = NULL;
  return temp;
}
inline void MessageCapsule::set_allocated_filter(::protbuf::Filter* filter) {
  delete filter_;
  filter_ = filter;
  if (filter) {
    set_has_filter();
  } else {
    clear_has_filter();
  }
}

// optional .protbuf.Limits limits = 6;
inline bool MessageCapsule::has_limits() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MessageCapsule::set_has_limits() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MessageCapsule::clear_has_limits() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MessageCapsule::clear_limits() {
  if (limits_ != NULL) limits_->::protbuf::Limits::Clear();
  clear_has_limits();
}
inline const ::protbuf::Limits& MessageCapsule::limits() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return limits_ != NULL ? *limits_ : *default_instance().limits_;
#else
  return limits_ != NULL ? *limits_ : *default_instance_->limits_;
#endif
}
inline ::protbuf::Limits* MessageCapsule::mutable_limits() {
  set_has_limits();
  if (limits_ == NULL) limits_ = new ::protbuf::Limits;
  return limits_;
}
inline ::protbuf::Limits* MessageCapsule::release_limits() {
  clear_has_limits();
  ::protbuf::Limits* temp = limits_;
  limits_ = NULL;
  return temp;
}
inline void MessageCapsule::set_allocated_limits(::protbuf::Limits* limits) {
  delete limits_;
  limits_ = limits;
  if (limits) {
    set_has_limits();
  } else {
    clear_has_limits();
  }
}

// optional .protbuf.OrderBy order = 7;
inline bool MessageCapsule::has_order() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MessageCapsule::set_has_order() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MessageCapsule::clear_has_order() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MessageCapsule::clear_order() {
  if (order_ != NULL) order_->::protbuf::OrderBy::Clear();
  clear_has_order();
}
inline const ::protbuf::OrderBy& MessageCapsule::order() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return order_ != NULL ? *order_ : *default_instance().order_;
#else
  return order_ != NULL ? *order_ : *default_instance_->order_;
#endif
}
inline ::protbuf::OrderBy* MessageCapsule::mutable_order() {
  set_has_order();
  if (order_ == NULL) order_ = new ::protbuf::OrderBy;
  return order_;
}
inline ::protbuf::OrderBy* MessageCapsule::release_order() {
  clear_has_order();
  ::protbuf::OrderBy* temp = order_;
  order_ = NULL;
  return temp;
}
inline void MessageCapsule::set_allocated_order(::protbuf::OrderBy* order) {
  delete order_;
  order_ = order;
  if (order) {
    set_has_order();
  } else {
    clear_has_order();
  }
}

// optional bool compressed = 8;
inline bool MessageCapsule::has_compressed() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MessageCapsule::set_has_compressed() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MessageCapsule::clear_has_compressed() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MessageCapsule::clear_compressed() {
  compressed_ = false;
  clear_has_compressed();
}
inline bool MessageCapsule::compressed() const {
  return compressed_;
}
inline void MessageCapsule::set_compressed(bool value) {
  set_has_compressed();
  compressed_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protbuf

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_message_5fconteiner_2eproto__INCLUDED
