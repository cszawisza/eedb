// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: user.proto

#ifndef PROTOBUF_user_2eproto__INCLUDED
#define PROTOBUF_user_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "storage.pb.h"
#include "stats.pb.h"
#include "common.pb.h"
// @@protoc_insertion_point(includes)

namespace protbuf {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_user_2eproto();
void protobuf_AssignDesc_user_2eproto();
void protobuf_ShutdownFile_user_2eproto();

class LoginRequest;
class UserDetails;
class UserStatistics;
class UserConfig;
class UserFullData;

enum Replay {
  LoginPass = 1,
  LoginDeny = 2,
  EmailExists = 3,
  EmailAddressToLong = 4,
  EmailNotValidate = 5,
  PasswordToShort = 6,
  UserNameToLong = 11,
  UserNameToShort = 12,
  UserAlreadyExists = 13,
  UserAddOk = 14,
  UserAlreadyLogged = 21,
  LogoutOk = 22,
  UserNotLogged = 23
};
bool Replay_IsValid(int value);
const Replay Replay_MIN = LoginPass;
const Replay Replay_MAX = UserNotLogged;
const int Replay_ARRAYSIZE = Replay_MAX + 1;

// ===================================================================

class LoginRequest : public ::google::protobuf::MessageLite {
 public:
  LoginRequest();
  virtual ~LoginRequest();

  LoginRequest(const LoginRequest& from);

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const LoginRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoginRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoginRequest* other);

  // implements Message ----------------------------------------------

  LoginRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoginRequest& from);
  void MergeFrom(const LoginRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string password = 4;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 4;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:protbuf.LoginRequest)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_password();
  inline void clear_has_password();

  ::std::string* name_;
  ::std::string* password_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static LoginRequest* default_instance_;
};
// -------------------------------------------------------------------

class UserDetails : public ::google::protobuf::MessageLite {
 public:
  UserDetails();
  virtual ~UserDetails();

  UserDetails(const UserDetails& from);

  inline UserDetails& operator=(const UserDetails& from) {
    CopyFrom(from);
    return *this;
  }

  static const UserDetails& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserDetails* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserDetails* other);

  // implements Message ----------------------------------------------

  UserDetails* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserDetails& from);
  void MergeFrom(const UserDetails& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string email = 1;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 1;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string address = 3;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 3;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const char* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  inline void set_allocated_address(::std::string* address);

  // optional bytes phone_number = 4;
  inline bool has_phone_number() const;
  inline void clear_phone_number();
  static const int kPhoneNumberFieldNumber = 4;
  inline const ::std::string& phone_number() const;
  inline void set_phone_number(const ::std::string& value);
  inline void set_phone_number(const char* value);
  inline void set_phone_number(const void* value, size_t size);
  inline ::std::string* mutable_phone_number();
  inline ::std::string* release_phone_number();
  inline void set_allocated_phone_number(::std::string* phone_number);

  // optional bytes description = 5;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 5;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const void* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // optional bytes avatar = 6;
  inline bool has_avatar() const;
  inline void clear_avatar();
  static const int kAvatarFieldNumber = 6;
  inline const ::std::string& avatar() const;
  inline void set_avatar(const ::std::string& value);
  inline void set_avatar(const char* value);
  inline void set_avatar(const void* value, size_t size);
  inline ::std::string* mutable_avatar();
  inline ::std::string* release_avatar();
  inline void set_allocated_avatar(::std::string* avatar);

  // @@protoc_insertion_point(class_scope:protbuf.UserDetails)
 private:
  inline void set_has_email();
  inline void clear_has_email();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_phone_number();
  inline void clear_has_phone_number();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_avatar();
  inline void clear_has_avatar();

  ::std::string* email_;
  ::std::string* name_;
  ::std::string* address_;
  ::std::string* phone_number_;
  ::std::string* description_;
  ::std::string* avatar_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static UserDetails* default_instance_;
};
// -------------------------------------------------------------------

class UserStatistics : public ::google::protobuf::MessageLite {
 public:
  UserStatistics();
  virtual ~UserStatistics();

  UserStatistics(const UserStatistics& from);

  inline UserStatistics& operator=(const UserStatistics& from) {
    CopyFrom(from);
    return *this;
  }

  static const UserStatistics& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserStatistics* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserStatistics* other);

  // implements Message ----------------------------------------------

  UserStatistics* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserStatistics& from);
  void MergeFrom(const UserStatistics& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 last_login = 7;
  inline bool has_last_login() const;
  inline void clear_last_login();
  static const int kLastLoginFieldNumber = 7;
  inline ::google::protobuf::uint64 last_login() const;
  inline void set_last_login(::google::protobuf::uint64 value);

  // optional fixed64 registration_date = 8;
  inline bool has_registration_date() const;
  inline void clear_registration_date();
  static const int kRegistrationDateFieldNumber = 8;
  inline ::google::protobuf::uint64 registration_date() const;
  inline void set_registration_date(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:protbuf.UserStatistics)
 private:
  inline void set_has_last_login();
  inline void clear_has_last_login();
  inline void set_has_registration_date();
  inline void clear_has_registration_date();

  ::google::protobuf::uint64 last_login_;
  ::google::protobuf::uint64 registration_date_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static UserStatistics* default_instance_;
};
// -------------------------------------------------------------------

class UserConfig : public ::google::protobuf::MessageLite {
 public:
  UserConfig();
  virtual ~UserConfig();

  UserConfig(const UserConfig& from);

  inline UserConfig& operator=(const UserConfig& from) {
    CopyFrom(from);
    return *this;
  }

  static const UserConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserConfig* other);

  // implements Message ----------------------------------------------

  UserConfig* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserConfig& from);
  void MergeFrom(const UserConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 last_storage_id = 1;
  inline bool has_last_storage_id() const;
  inline void clear_last_storage_id();
  static const int kLastStorageIdFieldNumber = 1;
  inline ::google::protobuf::uint32 last_storage_id() const;
  inline void set_last_storage_id(::google::protobuf::uint32 value);

  // optional uint32 last_group = 2;
  inline bool has_last_group() const;
  inline void clear_last_group();
  static const int kLastGroupFieldNumber = 2;
  inline ::google::protobuf::uint32 last_group() const;
  inline void set_last_group(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protbuf.UserConfig)
 private:
  inline void set_has_last_storage_id();
  inline void clear_has_last_storage_id();
  inline void set_has_last_group();
  inline void clear_has_last_group();

  ::google::protobuf::uint32 last_storage_id_;
  ::google::protobuf::uint32 last_group_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static UserConfig* default_instance_;
};
// -------------------------------------------------------------------

class UserFullData : public ::google::protobuf::MessageLite {
 public:
  UserFullData();
  virtual ~UserFullData();

  UserFullData(const UserFullData& from);

  inline UserFullData& operator=(const UserFullData& from) {
    CopyFrom(from);
    return *this;
  }

  static const UserFullData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserFullData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserFullData* other);

  // implements Message ----------------------------------------------

  UserFullData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserFullData& from);
  void MergeFrom(const UserFullData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .IdField basic = 1;
  inline bool has_basic() const;
  inline void clear_basic();
  static const int kBasicFieldNumber = 1;
  inline const ::IdField& basic() const;
  inline ::IdField* mutable_basic();
  inline ::IdField* release_basic();
  inline void set_allocated_basic(::IdField* basic);

  // required .protbuf.UserDetails details = 2;
  inline bool has_details() const;
  inline void clear_details();
  static const int kDetailsFieldNumber = 2;
  inline const ::protbuf::UserDetails& details() const;
  inline ::protbuf::UserDetails* mutable_details();
  inline ::protbuf::UserDetails* release_details();
  inline void set_allocated_details(::protbuf::UserDetails* details);

  // optional .protbuf.UserConfig config = 3;
  inline bool has_config() const;
  inline void clear_config();
  static const int kConfigFieldNumber = 3;
  inline const ::protbuf::UserConfig& config() const;
  inline ::protbuf::UserConfig* mutable_config();
  inline ::protbuf::UserConfig* release_config();
  inline void set_allocated_config(::protbuf::UserConfig* config);

  // optional .protbuf.UserStatistics stats = 4;
  inline bool has_stats() const;
  inline void clear_stats();
  static const int kStatsFieldNumber = 4;
  inline const ::protbuf::UserStatistics& stats() const;
  inline ::protbuf::UserStatistics* mutable_stats();
  inline ::protbuf::UserStatistics* release_stats();
  inline void set_allocated_stats(::protbuf::UserStatistics* stats);

  // repeated .protbuf.Storage storages = 5;
  inline int storages_size() const;
  inline void clear_storages();
  static const int kStoragesFieldNumber = 5;
  inline const ::protbuf::Storage& storages(int index) const;
  inline ::protbuf::Storage* mutable_storages(int index);
  inline ::protbuf::Storage* add_storages();
  inline const ::google::protobuf::RepeatedPtrField< ::protbuf::Storage >&
      storages() const;
  inline ::google::protobuf::RepeatedPtrField< ::protbuf::Storage >*
      mutable_storages();

  // optional string password = 6;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 6;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:protbuf.UserFullData)
 private:
  inline void set_has_basic();
  inline void clear_has_basic();
  inline void set_has_details();
  inline void clear_has_details();
  inline void set_has_config();
  inline void clear_has_config();
  inline void set_has_stats();
  inline void clear_has_stats();
  inline void set_has_password();
  inline void clear_has_password();

  ::IdField* basic_;
  ::protbuf::UserDetails* details_;
  ::protbuf::UserConfig* config_;
  ::protbuf::UserStatistics* stats_;
  ::google::protobuf::RepeatedPtrField< ::protbuf::Storage > storages_;
  ::std::string* password_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static UserFullData* default_instance_;
};
// ===================================================================


// ===================================================================

// LoginRequest

// required string name = 3;
inline bool LoginRequest::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginRequest::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginRequest::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginRequest::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& LoginRequest::name() const {
  return *name_;
}
inline void LoginRequest::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void LoginRequest::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void LoginRequest::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* LoginRequest::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginRequest::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string password = 4;
inline bool LoginRequest::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginRequest::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginRequest::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginRequest::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& LoginRequest::password() const {
  return *password_;
}
inline void LoginRequest::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void LoginRequest::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void LoginRequest::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* LoginRequest::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginRequest::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UserDetails

// optional string email = 1;
inline bool UserDetails::has_email() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserDetails::set_has_email() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserDetails::clear_has_email() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserDetails::clear_email() {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& UserDetails::email() const {
  return *email_;
}
inline void UserDetails::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void UserDetails::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void UserDetails::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserDetails::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  return email_;
}
inline ::std::string* UserDetails::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserDetails::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 2;
inline bool UserDetails::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserDetails::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserDetails::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserDetails::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& UserDetails::name() const {
  return *name_;
}
inline void UserDetails::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void UserDetails::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void UserDetails::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserDetails::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* UserDetails::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserDetails::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string address = 3;
inline bool UserDetails::has_address() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserDetails::set_has_address() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserDetails::clear_has_address() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserDetails::clear_address() {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& UserDetails::address() const {
  return *address_;
}
inline void UserDetails::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void UserDetails::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void UserDetails::set_address(const char* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserDetails::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  return address_;
}
inline ::std::string* UserDetails::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserDetails::set_allocated_address(::std::string* address) {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    delete address_;
  }
  if (address) {
    set_has_address();
    address_ = address;
  } else {
    clear_has_address();
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes phone_number = 4;
inline bool UserDetails::has_phone_number() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserDetails::set_has_phone_number() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserDetails::clear_has_phone_number() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserDetails::clear_phone_number() {
  if (phone_number_ != &::google::protobuf::internal::kEmptyString) {
    phone_number_->clear();
  }
  clear_has_phone_number();
}
inline const ::std::string& UserDetails::phone_number() const {
  return *phone_number_;
}
inline void UserDetails::set_phone_number(const ::std::string& value) {
  set_has_phone_number();
  if (phone_number_ == &::google::protobuf::internal::kEmptyString) {
    phone_number_ = new ::std::string;
  }
  phone_number_->assign(value);
}
inline void UserDetails::set_phone_number(const char* value) {
  set_has_phone_number();
  if (phone_number_ == &::google::protobuf::internal::kEmptyString) {
    phone_number_ = new ::std::string;
  }
  phone_number_->assign(value);
}
inline void UserDetails::set_phone_number(const void* value, size_t size) {
  set_has_phone_number();
  if (phone_number_ == &::google::protobuf::internal::kEmptyString) {
    phone_number_ = new ::std::string;
  }
  phone_number_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserDetails::mutable_phone_number() {
  set_has_phone_number();
  if (phone_number_ == &::google::protobuf::internal::kEmptyString) {
    phone_number_ = new ::std::string;
  }
  return phone_number_;
}
inline ::std::string* UserDetails::release_phone_number() {
  clear_has_phone_number();
  if (phone_number_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phone_number_;
    phone_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserDetails::set_allocated_phone_number(::std::string* phone_number) {
  if (phone_number_ != &::google::protobuf::internal::kEmptyString) {
    delete phone_number_;
  }
  if (phone_number) {
    set_has_phone_number();
    phone_number_ = phone_number;
  } else {
    clear_has_phone_number();
    phone_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes description = 5;
inline bool UserDetails::has_description() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserDetails::set_has_description() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserDetails::clear_has_description() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserDetails::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& UserDetails::description() const {
  return *description_;
}
inline void UserDetails::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void UserDetails::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void UserDetails::set_description(const void* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserDetails::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* UserDetails::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserDetails::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes avatar = 6;
inline bool UserDetails::has_avatar() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserDetails::set_has_avatar() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserDetails::clear_has_avatar() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserDetails::clear_avatar() {
  if (avatar_ != &::google::protobuf::internal::kEmptyString) {
    avatar_->clear();
  }
  clear_has_avatar();
}
inline const ::std::string& UserDetails::avatar() const {
  return *avatar_;
}
inline void UserDetails::set_avatar(const ::std::string& value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
}
inline void UserDetails::set_avatar(const char* value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
}
inline void UserDetails::set_avatar(const void* value, size_t size) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserDetails::mutable_avatar() {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  return avatar_;
}
inline ::std::string* UserDetails::release_avatar() {
  clear_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = avatar_;
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserDetails::set_allocated_avatar(::std::string* avatar) {
  if (avatar_ != &::google::protobuf::internal::kEmptyString) {
    delete avatar_;
  }
  if (avatar) {
    set_has_avatar();
    avatar_ = avatar;
  } else {
    clear_has_avatar();
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UserStatistics

// optional fixed64 last_login = 7;
inline bool UserStatistics::has_last_login() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserStatistics::set_has_last_login() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserStatistics::clear_has_last_login() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserStatistics::clear_last_login() {
  last_login_ = GOOGLE_ULONGLONG(0);
  clear_has_last_login();
}
inline ::google::protobuf::uint64 UserStatistics::last_login() const {
  return last_login_;
}
inline void UserStatistics::set_last_login(::google::protobuf::uint64 value) {
  set_has_last_login();
  last_login_ = value;
}

// optional fixed64 registration_date = 8;
inline bool UserStatistics::has_registration_date() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserStatistics::set_has_registration_date() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserStatistics::clear_has_registration_date() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserStatistics::clear_registration_date() {
  registration_date_ = GOOGLE_ULONGLONG(0);
  clear_has_registration_date();
}
inline ::google::protobuf::uint64 UserStatistics::registration_date() const {
  return registration_date_;
}
inline void UserStatistics::set_registration_date(::google::protobuf::uint64 value) {
  set_has_registration_date();
  registration_date_ = value;
}

// -------------------------------------------------------------------

// UserConfig

// optional uint32 last_storage_id = 1;
inline bool UserConfig::has_last_storage_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserConfig::set_has_last_storage_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserConfig::clear_has_last_storage_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserConfig::clear_last_storage_id() {
  last_storage_id_ = 0u;
  clear_has_last_storage_id();
}
inline ::google::protobuf::uint32 UserConfig::last_storage_id() const {
  return last_storage_id_;
}
inline void UserConfig::set_last_storage_id(::google::protobuf::uint32 value) {
  set_has_last_storage_id();
  last_storage_id_ = value;
}

// optional uint32 last_group = 2;
inline bool UserConfig::has_last_group() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserConfig::set_has_last_group() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserConfig::clear_has_last_group() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserConfig::clear_last_group() {
  last_group_ = 0u;
  clear_has_last_group();
}
inline ::google::protobuf::uint32 UserConfig::last_group() const {
  return last_group_;
}
inline void UserConfig::set_last_group(::google::protobuf::uint32 value) {
  set_has_last_group();
  last_group_ = value;
}

// -------------------------------------------------------------------

// UserFullData

// required .IdField basic = 1;
inline bool UserFullData::has_basic() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserFullData::set_has_basic() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserFullData::clear_has_basic() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserFullData::clear_basic() {
  if (basic_ != NULL) basic_->::IdField::Clear();
  clear_has_basic();
}
inline const ::IdField& UserFullData::basic() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return basic_ != NULL ? *basic_ : *default_instance().basic_;
#else
  return basic_ != NULL ? *basic_ : *default_instance_->basic_;
#endif
}
inline ::IdField* UserFullData::mutable_basic() {
  set_has_basic();
  if (basic_ == NULL) basic_ = new ::IdField;
  return basic_;
}
inline ::IdField* UserFullData::release_basic() {
  clear_has_basic();
  ::IdField* temp = basic_;
  basic_ = NULL;
  return temp;
}
inline void UserFullData::set_allocated_basic(::IdField* basic) {
  delete basic_;
  basic_ = basic;
  if (basic) {
    set_has_basic();
  } else {
    clear_has_basic();
  }
}

// required .protbuf.UserDetails details = 2;
inline bool UserFullData::has_details() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserFullData::set_has_details() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserFullData::clear_has_details() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserFullData::clear_details() {
  if (details_ != NULL) details_->::protbuf::UserDetails::Clear();
  clear_has_details();
}
inline const ::protbuf::UserDetails& UserFullData::details() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return details_ != NULL ? *details_ : *default_instance().details_;
#else
  return details_ != NULL ? *details_ : *default_instance_->details_;
#endif
}
inline ::protbuf::UserDetails* UserFullData::mutable_details() {
  set_has_details();
  if (details_ == NULL) details_ = new ::protbuf::UserDetails;
  return details_;
}
inline ::protbuf::UserDetails* UserFullData::release_details() {
  clear_has_details();
  ::protbuf::UserDetails* temp = details_;
  details_ = NULL;
  return temp;
}
inline void UserFullData::set_allocated_details(::protbuf::UserDetails* details) {
  delete details_;
  details_ = details;
  if (details) {
    set_has_details();
  } else {
    clear_has_details();
  }
}

// optional .protbuf.UserConfig config = 3;
inline bool UserFullData::has_config() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserFullData::set_has_config() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserFullData::clear_has_config() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserFullData::clear_config() {
  if (config_ != NULL) config_->::protbuf::UserConfig::Clear();
  clear_has_config();
}
inline const ::protbuf::UserConfig& UserFullData::config() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return config_ != NULL ? *config_ : *default_instance().config_;
#else
  return config_ != NULL ? *config_ : *default_instance_->config_;
#endif
}
inline ::protbuf::UserConfig* UserFullData::mutable_config() {
  set_has_config();
  if (config_ == NULL) config_ = new ::protbuf::UserConfig;
  return config_;
}
inline ::protbuf::UserConfig* UserFullData::release_config() {
  clear_has_config();
  ::protbuf::UserConfig* temp = config_;
  config_ = NULL;
  return temp;
}
inline void UserFullData::set_allocated_config(::protbuf::UserConfig* config) {
  delete config_;
  config_ = config;
  if (config) {
    set_has_config();
  } else {
    clear_has_config();
  }
}

// optional .protbuf.UserStatistics stats = 4;
inline bool UserFullData::has_stats() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserFullData::set_has_stats() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserFullData::clear_has_stats() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserFullData::clear_stats() {
  if (stats_ != NULL) stats_->::protbuf::UserStatistics::Clear();
  clear_has_stats();
}
inline const ::protbuf::UserStatistics& UserFullData::stats() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return stats_ != NULL ? *stats_ : *default_instance().stats_;
#else
  return stats_ != NULL ? *stats_ : *default_instance_->stats_;
#endif
}
inline ::protbuf::UserStatistics* UserFullData::mutable_stats() {
  set_has_stats();
  if (stats_ == NULL) stats_ = new ::protbuf::UserStatistics;
  return stats_;
}
inline ::protbuf::UserStatistics* UserFullData::release_stats() {
  clear_has_stats();
  ::protbuf::UserStatistics* temp = stats_;
  stats_ = NULL;
  return temp;
}
inline void UserFullData::set_allocated_stats(::protbuf::UserStatistics* stats) {
  delete stats_;
  stats_ = stats;
  if (stats) {
    set_has_stats();
  } else {
    clear_has_stats();
  }
}

// repeated .protbuf.Storage storages = 5;
inline int UserFullData::storages_size() const {
  return storages_.size();
}
inline void UserFullData::clear_storages() {
  storages_.Clear();
}
inline const ::protbuf::Storage& UserFullData::storages(int index) const {
  return storages_.Get(index);
}
inline ::protbuf::Storage* UserFullData::mutable_storages(int index) {
  return storages_.Mutable(index);
}
inline ::protbuf::Storage* UserFullData::add_storages() {
  return storages_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protbuf::Storage >&
UserFullData::storages() const {
  return storages_;
}
inline ::google::protobuf::RepeatedPtrField< ::protbuf::Storage >*
UserFullData::mutable_storages() {
  return &storages_;
}

// optional string password = 6;
inline bool UserFullData::has_password() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserFullData::set_has_password() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserFullData::clear_has_password() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserFullData::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& UserFullData::password() const {
  return *password_;
}
inline void UserFullData::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void UserFullData::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void UserFullData::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserFullData::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* UserFullData::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserFullData::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protbuf

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_user_2eproto__INCLUDED
