// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message_conteiner.proto

#ifndef PROTOBUF_message_5fconteiner_2eproto__INCLUDED
#define PROTOBUF_message_5fconteiner_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "common.pb.h"  // IWYU pragma: export
#include "user.pb.h"  // IWYU pragma: export
// @@protoc_insertion_point(includes)

namespace protbuf {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_message_5fconteiner_2eproto();
void protobuf_AssignDesc_message_5fconteiner_2eproto();
void protobuf_ShutdownFile_message_5fconteiner_2eproto();

class ClientRequests;
class ClientRequest;
class ServerResponses;
class ServerResponse;

enum MsgCoding {
  msgProtbuf = 1,
  msgBin = 2,
  msgJson = 3
};
bool MsgCoding_IsValid(int value);
const MsgCoding MsgCoding_MIN = msgProtbuf;
const MsgCoding MsgCoding_MAX = msgJson;
const int MsgCoding_ARRAYSIZE = MsgCoding_MAX + 1;

enum MsgTypeId {
  Msg_unknown = 0,
  Msg_Server_Response = 100,
  Msg_User_req = 12,
  Msg_User_res = 13
};
bool MsgTypeId_IsValid(int value);
const MsgTypeId MsgTypeId_MIN = Msg_unknown;
const MsgTypeId MsgTypeId_MAX = Msg_Server_Response;
const int MsgTypeId_ARRAYSIZE = MsgTypeId_MAX + 1;

enum ServerErrorCodes {
  Error_MsgUnknown = 1
};
bool ServerErrorCodes_IsValid(int value);
const ServerErrorCodes ServerErrorCodes_MIN = Error_MsgUnknown;
const ServerErrorCodes ServerErrorCodes_MAX = Error_MsgUnknown;
const int ServerErrorCodes_ARRAYSIZE = ServerErrorCodes_MAX + 1;

// ===================================================================

class ClientRequests : public ::google::protobuf::MessageLite {
 public:
  ClientRequests();
  virtual ~ClientRequests();

  ClientRequests(const ClientRequests& from);

  inline ClientRequests& operator=(const ClientRequests& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ClientRequests& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ClientRequests* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ClientRequests* other);

  // implements Message ----------------------------------------------

  ClientRequests* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientRequests& from);
  void MergeFrom(const ClientRequests& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protbuf.ClientRequest request = 1;
  inline int request_size() const;
  inline void clear_request();
  static const int kRequestFieldNumber = 1;
  inline const ::protbuf::ClientRequest& request(int index) const;
  inline ::protbuf::ClientRequest* mutable_request(int index);
  inline ::protbuf::ClientRequest* add_request();
  inline const ::google::protobuf::RepeatedPtrField< ::protbuf::ClientRequest >&
      request() const;
  inline ::google::protobuf::RepeatedPtrField< ::protbuf::ClientRequest >*
      mutable_request();

  // @@protoc_insertion_point(class_scope:protbuf.ClientRequests)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::protbuf::ClientRequest > request_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_5fconteiner_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_5fconteiner_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_5fconteiner_2eproto();
  friend void protobuf_ShutdownFile_message_5fconteiner_2eproto();

  void InitAsDefaultInstance();
  static ClientRequests* default_instance_;
};
// -------------------------------------------------------------------

class ClientRequest : public ::google::protobuf::MessageLite {
 public:
  ClientRequest();
  virtual ~ClientRequest();

  ClientRequest(const ClientRequest& from);

  inline ClientRequest& operator=(const ClientRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ClientRequest& default_instance();

  enum DataCase {
    kMsgUserReq = 12,
    DATA_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ClientRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ClientRequest* other);

  // implements Message ----------------------------------------------

  ClientRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientRequest& from);
  void MergeFrom(const ClientRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 requestId = 1 [default = 1];
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIdFieldNumber = 1;
  inline ::google::protobuf::uint32 requestid() const;
  inline void set_requestid(::google::protobuf::uint32 value);

  // optional .user.MsgUserRequest msgUserReq = 12;
  inline bool has_msguserreq() const;
  inline void clear_msguserreq();
  static const int kMsgUserReqFieldNumber = 12;
  inline const ::user::MsgUserRequest& msguserreq() const;
  inline ::user::MsgUserRequest* mutable_msguserreq();
  inline ::user::MsgUserRequest* release_msguserreq();
  inline void set_allocated_msguserreq(::user::MsgUserRequest* msguserreq);

  inline DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:protbuf.ClientRequest)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();
  inline void set_has_msguserreq();

  inline bool has_data();
  void clear_data();
  inline void clear_has_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 requestid_;
  union DataUnion {
    ::user::MsgUserRequest* msguserreq_;
  } data_;
  ::google::protobuf::uint32 _oneof_case_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_5fconteiner_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_5fconteiner_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_5fconteiner_2eproto();
  friend void protobuf_ShutdownFile_message_5fconteiner_2eproto();

  void InitAsDefaultInstance();
  static ClientRequest* default_instance_;
};
// -------------------------------------------------------------------

class ServerResponses : public ::google::protobuf::MessageLite {
 public:
  ServerResponses();
  virtual ~ServerResponses();

  ServerResponses(const ServerResponses& from);

  inline ServerResponses& operator=(const ServerResponses& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ServerResponses& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ServerResponses* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ServerResponses* other);

  // implements Message ----------------------------------------------

  ServerResponses* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ServerResponses& from);
  void MergeFrom(const ServerResponses& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protbuf.ServerResponse response = 1;
  inline int response_size() const;
  inline void clear_response();
  static const int kResponseFieldNumber = 1;
  inline const ::protbuf::ServerResponse& response(int index) const;
  inline ::protbuf::ServerResponse* mutable_response(int index);
  inline ::protbuf::ServerResponse* add_response();
  inline const ::google::protobuf::RepeatedPtrField< ::protbuf::ServerResponse >&
      response() const;
  inline ::google::protobuf::RepeatedPtrField< ::protbuf::ServerResponse >*
      mutable_response();

  // @@protoc_insertion_point(class_scope:protbuf.ServerResponses)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::protbuf::ServerResponse > response_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_5fconteiner_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_5fconteiner_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_5fconteiner_2eproto();
  friend void protobuf_ShutdownFile_message_5fconteiner_2eproto();

  void InitAsDefaultInstance();
  static ServerResponses* default_instance_;
};
// -------------------------------------------------------------------

class ServerResponse : public ::google::protobuf::MessageLite {
 public:
  ServerResponse();
  virtual ~ServerResponse();

  ServerResponse(const ServerResponse& from);

  inline ServerResponse& operator=(const ServerResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ServerResponse& default_instance();

  enum DataCase {
    kMsgUserRes = 13,
    kMsgServerResponse = 1000,
    DATA_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ServerResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ServerResponse* other);

  // implements Message ----------------------------------------------

  ServerResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ServerResponse& from);
  void MergeFrom(const ServerResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ResponseCode codes = 1;
  inline int codes_size() const;
  inline void clear_codes();
  static const int kCodesFieldNumber = 1;
  inline const ::ResponseCode& codes(int index) const;
  inline ::ResponseCode* mutable_codes(int index);
  inline ::ResponseCode* add_codes();
  inline const ::google::protobuf::RepeatedPtrField< ::ResponseCode >&
      codes() const;
  inline ::google::protobuf::RepeatedPtrField< ::ResponseCode >*
      mutable_codes();

  // optional uint32 responseId = 2 [default = 0];
  inline bool has_responseid() const;
  inline void clear_responseid();
  static const int kResponseIdFieldNumber = 2;
  inline ::google::protobuf::uint32 responseid() const;
  inline void set_responseid(::google::protobuf::uint32 value);

  // optional .user.MsgUserResponse msgUserRes = 13;
  inline bool has_msguserres() const;
  inline void clear_msguserres();
  static const int kMsgUserResFieldNumber = 13;
  inline const ::user::MsgUserResponse& msguserres() const;
  inline ::user::MsgUserResponse* mutable_msguserres();
  inline ::user::MsgUserResponse* release_msguserres();
  inline void set_allocated_msguserres(::user::MsgUserResponse* msguserres);

  // optional .protbuf.ServerResponse msgServerResponse = 1000;
  inline bool has_msgserverresponse() const;
  inline void clear_msgserverresponse();
  static const int kMsgServerResponseFieldNumber = 1000;
  inline const ::protbuf::ServerResponse& msgserverresponse() const;
  inline ::protbuf::ServerResponse* mutable_msgserverresponse();
  inline ::protbuf::ServerResponse* release_msgserverresponse();
  inline void set_allocated_msgserverresponse(::protbuf::ServerResponse* msgserverresponse);

  inline DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:protbuf.ServerResponse)
 private:
  inline void set_has_responseid();
  inline void clear_has_responseid();
  inline void set_has_msguserres();
  inline void set_has_msgserverresponse();

  inline bool has_data();
  void clear_data();
  inline void clear_has_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ResponseCode > codes_;
  ::google::protobuf::uint32 responseid_;
  union DataUnion {
    ::user::MsgUserResponse* msguserres_;
    ::protbuf::ServerResponse* msgserverresponse_;
  } data_;
  ::google::protobuf::uint32 _oneof_case_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_message_5fconteiner_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_message_5fconteiner_2eproto();
  #endif
  friend void protobuf_AssignDesc_message_5fconteiner_2eproto();
  friend void protobuf_ShutdownFile_message_5fconteiner_2eproto();

  void InitAsDefaultInstance();
  static ServerResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// ClientRequests

// repeated .protbuf.ClientRequest request = 1;
inline int ClientRequests::request_size() const {
  return request_.size();
}
inline void ClientRequests::clear_request() {
  request_.Clear();
}
inline const ::protbuf::ClientRequest& ClientRequests::request(int index) const {
  // @@protoc_insertion_point(field_get:protbuf.ClientRequests.request)
  return request_.Get(index);
}
inline ::protbuf::ClientRequest* ClientRequests::mutable_request(int index) {
  // @@protoc_insertion_point(field_mutable:protbuf.ClientRequests.request)
  return request_.Mutable(index);
}
inline ::protbuf::ClientRequest* ClientRequests::add_request() {
  // @@protoc_insertion_point(field_add:protbuf.ClientRequests.request)
  return request_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protbuf::ClientRequest >&
ClientRequests::request() const {
  // @@protoc_insertion_point(field_list:protbuf.ClientRequests.request)
  return request_;
}
inline ::google::protobuf::RepeatedPtrField< ::protbuf::ClientRequest >*
ClientRequests::mutable_request() {
  // @@protoc_insertion_point(field_mutable_list:protbuf.ClientRequests.request)
  return &request_;
}

// -------------------------------------------------------------------

// ClientRequest

// optional uint32 requestId = 1 [default = 1];
inline bool ClientRequest::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientRequest::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientRequest::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientRequest::clear_requestid() {
  requestid_ = 1u;
  clear_has_requestid();
}
inline ::google::protobuf::uint32 ClientRequest::requestid() const {
  // @@protoc_insertion_point(field_get:protbuf.ClientRequest.requestId)
  return requestid_;
}
inline void ClientRequest::set_requestid(::google::protobuf::uint32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:protbuf.ClientRequest.requestId)
}

// optional .user.MsgUserRequest msgUserReq = 12;
inline bool ClientRequest::has_msguserreq() const {
  return data_case() == kMsgUserReq;
}
inline void ClientRequest::set_has_msguserreq() {
  _oneof_case_[0] = kMsgUserReq;
}
inline void ClientRequest::clear_msguserreq() {
  if (has_msguserreq()) {
    delete data_.msguserreq_;
    clear_has_data();
  }
}
inline const ::user::MsgUserRequest& ClientRequest::msguserreq() const {
  return has_msguserreq() ? *data_.msguserreq_
                      : ::user::MsgUserRequest::default_instance();
}
inline ::user::MsgUserRequest* ClientRequest::mutable_msguserreq() {
  if (!has_msguserreq()) {
    clear_data();
    set_has_msguserreq();
    data_.msguserreq_ = new ::user::MsgUserRequest;
  }
  return data_.msguserreq_;
}
inline ::user::MsgUserRequest* ClientRequest::release_msguserreq() {
  if (has_msguserreq()) {
    clear_has_data();
    ::user::MsgUserRequest* temp = data_.msguserreq_;
    data_.msguserreq_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ClientRequest::set_allocated_msguserreq(::user::MsgUserRequest* msguserreq) {
  clear_data();
  if (msguserreq) {
    set_has_msguserreq();
    data_.msguserreq_ = msguserreq;
  }
}

inline bool ClientRequest::has_data() {
  return data_case() != DATA_NOT_SET;
}
inline void ClientRequest::clear_has_data() {
  _oneof_case_[0] = DATA_NOT_SET;
}
inline ClientRequest::DataCase ClientRequest::data_case() const {
  return ClientRequest::DataCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ServerResponses

// repeated .protbuf.ServerResponse response = 1;
inline int ServerResponses::response_size() const {
  return response_.size();
}
inline void ServerResponses::clear_response() {
  response_.Clear();
}
inline const ::protbuf::ServerResponse& ServerResponses::response(int index) const {
  // @@protoc_insertion_point(field_get:protbuf.ServerResponses.response)
  return response_.Get(index);
}
inline ::protbuf::ServerResponse* ServerResponses::mutable_response(int index) {
  // @@protoc_insertion_point(field_mutable:protbuf.ServerResponses.response)
  return response_.Mutable(index);
}
inline ::protbuf::ServerResponse* ServerResponses::add_response() {
  // @@protoc_insertion_point(field_add:protbuf.ServerResponses.response)
  return response_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protbuf::ServerResponse >&
ServerResponses::response() const {
  // @@protoc_insertion_point(field_list:protbuf.ServerResponses.response)
  return response_;
}
inline ::google::protobuf::RepeatedPtrField< ::protbuf::ServerResponse >*
ServerResponses::mutable_response() {
  // @@protoc_insertion_point(field_mutable_list:protbuf.ServerResponses.response)
  return &response_;
}

// -------------------------------------------------------------------

// ServerResponse

// repeated .ResponseCode codes = 1;
inline int ServerResponse::codes_size() const {
  return codes_.size();
}
inline void ServerResponse::clear_codes() {
  codes_.Clear();
}
inline const ::ResponseCode& ServerResponse::codes(int index) const {
  // @@protoc_insertion_point(field_get:protbuf.ServerResponse.codes)
  return codes_.Get(index);
}
inline ::ResponseCode* ServerResponse::mutable_codes(int index) {
  // @@protoc_insertion_point(field_mutable:protbuf.ServerResponse.codes)
  return codes_.Mutable(index);
}
inline ::ResponseCode* ServerResponse::add_codes() {
  // @@protoc_insertion_point(field_add:protbuf.ServerResponse.codes)
  return codes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ResponseCode >&
ServerResponse::codes() const {
  // @@protoc_insertion_point(field_list:protbuf.ServerResponse.codes)
  return codes_;
}
inline ::google::protobuf::RepeatedPtrField< ::ResponseCode >*
ServerResponse::mutable_codes() {
  // @@protoc_insertion_point(field_mutable_list:protbuf.ServerResponse.codes)
  return &codes_;
}

// optional uint32 responseId = 2 [default = 0];
inline bool ServerResponse::has_responseid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerResponse::set_has_responseid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerResponse::clear_has_responseid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerResponse::clear_responseid() {
  responseid_ = 0u;
  clear_has_responseid();
}
inline ::google::protobuf::uint32 ServerResponse::responseid() const {
  // @@protoc_insertion_point(field_get:protbuf.ServerResponse.responseId)
  return responseid_;
}
inline void ServerResponse::set_responseid(::google::protobuf::uint32 value) {
  set_has_responseid();
  responseid_ = value;
  // @@protoc_insertion_point(field_set:protbuf.ServerResponse.responseId)
}

// optional .user.MsgUserResponse msgUserRes = 13;
inline bool ServerResponse::has_msguserres() const {
  return data_case() == kMsgUserRes;
}
inline void ServerResponse::set_has_msguserres() {
  _oneof_case_[0] = kMsgUserRes;
}
inline void ServerResponse::clear_msguserres() {
  if (has_msguserres()) {
    delete data_.msguserres_;
    clear_has_data();
  }
}
inline const ::user::MsgUserResponse& ServerResponse::msguserres() const {
  return has_msguserres() ? *data_.msguserres_
                      : ::user::MsgUserResponse::default_instance();
}
inline ::user::MsgUserResponse* ServerResponse::mutable_msguserres() {
  if (!has_msguserres()) {
    clear_data();
    set_has_msguserres();
    data_.msguserres_ = new ::user::MsgUserResponse;
  }
  return data_.msguserres_;
}
inline ::user::MsgUserResponse* ServerResponse::release_msguserres() {
  if (has_msguserres()) {
    clear_has_data();
    ::user::MsgUserResponse* temp = data_.msguserres_;
    data_.msguserres_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ServerResponse::set_allocated_msguserres(::user::MsgUserResponse* msguserres) {
  clear_data();
  if (msguserres) {
    set_has_msguserres();
    data_.msguserres_ = msguserres;
  }
}

// optional .protbuf.ServerResponse msgServerResponse = 1000;
inline bool ServerResponse::has_msgserverresponse() const {
  return data_case() == kMsgServerResponse;
}
inline void ServerResponse::set_has_msgserverresponse() {
  _oneof_case_[0] = kMsgServerResponse;
}
inline void ServerResponse::clear_msgserverresponse() {
  if (has_msgserverresponse()) {
    delete data_.msgserverresponse_;
    clear_has_data();
  }
}
inline const ::protbuf::ServerResponse& ServerResponse::msgserverresponse() const {
  return has_msgserverresponse() ? *data_.msgserverresponse_
                      : ::protbuf::ServerResponse::default_instance();
}
inline ::protbuf::ServerResponse* ServerResponse::mutable_msgserverresponse() {
  if (!has_msgserverresponse()) {
    clear_data();
    set_has_msgserverresponse();
    data_.msgserverresponse_ = new ::protbuf::ServerResponse;
  }
  return data_.msgserverresponse_;
}
inline ::protbuf::ServerResponse* ServerResponse::release_msgserverresponse() {
  if (has_msgserverresponse()) {
    clear_has_data();
    ::protbuf::ServerResponse* temp = data_.msgserverresponse_;
    data_.msgserverresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ServerResponse::set_allocated_msgserverresponse(::protbuf::ServerResponse* msgserverresponse) {
  clear_data();
  if (msgserverresponse) {
    set_has_msgserverresponse();
    data_.msgserverresponse_ = msgserverresponse;
  }
}

inline bool ServerResponse::has_data() {
  return data_case() != DATA_NOT_SET;
}
inline void ServerResponse::clear_has_data() {
  _oneof_case_[0] = DATA_NOT_SET;
}
inline ServerResponse::DataCase ServerResponse::data_case() const {
  return ServerResponse::DataCase(_oneof_case_[0]);
}

// @@protoc_insertion_point(namespace_scope)

}  // namespace protbuf

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_message_5fconteiner_2eproto__INCLUDED
