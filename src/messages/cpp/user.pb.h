// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: user.proto

#ifndef PROTOBUF_user_2eproto__INCLUDED
#define PROTOBUF_user_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "storage.pb.h"  // IWYU pragma: export
#include "stats.pb.h"  // IWYU pragma: export
#include "common.pb.h"  // IWYU pragma: export
// @@protoc_insertion_point(includes)

namespace user {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_user_2eproto();
void protobuf_AssignDesc_user_2eproto();
void protobuf_ShutdownFile_user_2eproto();

class MsgUserRequest;
class MsgUserRequest_Credentials;
class MsgUserRequest_Login;
class MsgUserRequest_Logout;
class MsgUserRequest_Add;
class MsgUserRequest_Remove;
class MsgUserRequest_Modify;
class MsgUserRequest_Get;
class MsgUserResponse;
class UserDetails;
class UserConfig;
class UserStatis;

enum Action {
  Action_Add = 1,
  Action_Login = 2,
  Action_Logout = 3,
  Action_Remove = 4,
  Action_Modify = 5,
  Action_Get = 6
};
bool Action_IsValid(int value);
const Action Action_MIN = Action_Add;
const Action Action_MAX = Action_Get;
const int Action_ARRAYSIZE = Action_MAX + 1;

enum Replay {
  LoginPass = 1,
  LoginDeny = 2,
  EmailExists = 3,
  EmailAddressToLong = 4,
  EmailNotValidate = 5,
  PasswordToShort = 6,
  UserNameToLong = 11,
  UserNameToShort = 12,
  UserAlreadyExists = 13,
  UserAddOk = 14,
  UserAlreadyLogged = 21,
  LogoutOk = 22,
  UserNotLogged = 23
};
bool Replay_IsValid(int value);
const Replay Replay_MIN = LoginPass;
const Replay Replay_MAX = UserNotLogged;
const int Replay_ARRAYSIZE = Replay_MAX + 1;

// ===================================================================

class MsgUserRequest_Credentials : public ::google::protobuf::MessageLite {
 public:
  MsgUserRequest_Credentials();
  virtual ~MsgUserRequest_Credentials();

  MsgUserRequest_Credentials(const MsgUserRequest_Credentials& from);

  inline MsgUserRequest_Credentials& operator=(const MsgUserRequest_Credentials& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MsgUserRequest_Credentials& default_instance();

  enum LoginIdCase {
    kId = 1,
    kName = 2,
    kEmail = 3,
    LOGIN_ID_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MsgUserRequest_Credentials* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MsgUserRequest_Credentials* other);

  // implements Message ----------------------------------------------

  MsgUserRequest_Credentials* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MsgUserRequest_Credentials& from);
  void MergeFrom(const MsgUserRequest_Credentials& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string email = 3;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 3;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  inline LoginIdCase login_id_case() const;
  // @@protoc_insertion_point(class_scope:user.MsgUserRequest.Credentials)
 private:
  inline void set_has_id();
  inline void set_has_name();
  inline void set_has_email();

  inline bool has_login_id();
  void clear_login_id();
  inline void clear_has_login_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union LoginIdUnion {
    ::google::protobuf::uint32 id_;
    ::std::string* name_;
    ::std::string* email_;
  } login_id_;
  ::google::protobuf::uint32 _oneof_case_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static MsgUserRequest_Credentials* default_instance_;
};
// -------------------------------------------------------------------

class MsgUserRequest_Login : public ::google::protobuf::MessageLite {
 public:
  MsgUserRequest_Login();
  virtual ~MsgUserRequest_Login();

  MsgUserRequest_Login(const MsgUserRequest_Login& from);

  inline MsgUserRequest_Login& operator=(const MsgUserRequest_Login& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MsgUserRequest_Login& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MsgUserRequest_Login* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MsgUserRequest_Login* other);

  // implements Message ----------------------------------------------

  MsgUserRequest_Login* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MsgUserRequest_Login& from);
  void MergeFrom(const MsgUserRequest_Login& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .user.MsgUserRequest.Credentials cred = 1;
  inline bool has_cred() const;
  inline void clear_cred();
  static const int kCredFieldNumber = 1;
  inline const ::user::MsgUserRequest_Credentials& cred() const;
  inline ::user::MsgUserRequest_Credentials* mutable_cred();
  inline ::user::MsgUserRequest_Credentials* release_cred();
  inline void set_allocated_cred(::user::MsgUserRequest_Credentials* cred);

  // required string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:user.MsgUserRequest.Login)
 private:
  inline void set_has_cred();
  inline void clear_has_cred();
  inline void set_has_password();
  inline void clear_has_password();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::user::MsgUserRequest_Credentials* cred_;
  ::std::string* password_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static MsgUserRequest_Login* default_instance_;
};
// -------------------------------------------------------------------

class MsgUserRequest_Logout : public ::google::protobuf::MessageLite {
 public:
  MsgUserRequest_Logout();
  virtual ~MsgUserRequest_Logout();

  MsgUserRequest_Logout(const MsgUserRequest_Logout& from);

  inline MsgUserRequest_Logout& operator=(const MsgUserRequest_Logout& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MsgUserRequest_Logout& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MsgUserRequest_Logout* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MsgUserRequest_Logout* other);

  // implements Message ----------------------------------------------

  MsgUserRequest_Logout* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MsgUserRequest_Logout& from);
  void MergeFrom(const MsgUserRequest_Logout& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:user.MsgUserRequest.Logout)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static MsgUserRequest_Logout* default_instance_;
};
// -------------------------------------------------------------------

class MsgUserRequest_Add : public ::google::protobuf::MessageLite {
 public:
  MsgUserRequest_Add();
  virtual ~MsgUserRequest_Add();

  MsgUserRequest_Add(const MsgUserRequest_Add& from);

  inline MsgUserRequest_Add& operator=(const MsgUserRequest_Add& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MsgUserRequest_Add& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MsgUserRequest_Add* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MsgUserRequest_Add* other);

  // implements Message ----------------------------------------------

  MsgUserRequest_Add* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MsgUserRequest_Add& from);
  void MergeFrom(const MsgUserRequest_Add& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .user.UserDetails details = 1;
  inline bool has_details() const;
  inline void clear_details();
  static const int kDetailsFieldNumber = 1;
  inline const ::user::UserDetails& details() const;
  inline ::user::UserDetails* mutable_details();
  inline ::user::UserDetails* release_details();
  inline void set_allocated_details(::user::UserDetails* details);

  // optional .user.UserConfig config = 2;
  inline bool has_config() const;
  inline void clear_config();
  static const int kConfigFieldNumber = 2;
  inline const ::user::UserConfig& config() const;
  inline ::user::UserConfig* mutable_config();
  inline ::user::UserConfig* release_config();
  inline void set_allocated_config(::user::UserConfig* config);

  // optional string password = 3;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 3;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:user.MsgUserRequest.Add)
 private:
  inline void set_has_details();
  inline void clear_has_details();
  inline void set_has_config();
  inline void clear_has_config();
  inline void set_has_password();
  inline void clear_has_password();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::user::UserDetails* details_;
  ::user::UserConfig* config_;
  ::std::string* password_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static MsgUserRequest_Add* default_instance_;
};
// -------------------------------------------------------------------

class MsgUserRequest_Remove : public ::google::protobuf::MessageLite {
 public:
  MsgUserRequest_Remove();
  virtual ~MsgUserRequest_Remove();

  MsgUserRequest_Remove(const MsgUserRequest_Remove& from);

  inline MsgUserRequest_Remove& operator=(const MsgUserRequest_Remove& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MsgUserRequest_Remove& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MsgUserRequest_Remove* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MsgUserRequest_Remove* other);

  // implements Message ----------------------------------------------

  MsgUserRequest_Remove* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MsgUserRequest_Remove& from);
  void MergeFrom(const MsgUserRequest_Remove& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .user.MsgUserRequest.Credentials cred = 1;
  inline bool has_cred() const;
  inline void clear_cred();
  static const int kCredFieldNumber = 1;
  inline const ::user::MsgUserRequest_Credentials& cred() const;
  inline ::user::MsgUserRequest_Credentials* mutable_cred();
  inline ::user::MsgUserRequest_Credentials* release_cred();
  inline void set_allocated_cred(::user::MsgUserRequest_Credentials* cred);

  // @@protoc_insertion_point(class_scope:user.MsgUserRequest.Remove)
 private:
  inline void set_has_cred();
  inline void clear_has_cred();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::user::MsgUserRequest_Credentials* cred_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static MsgUserRequest_Remove* default_instance_;
};
// -------------------------------------------------------------------

class MsgUserRequest_Modify : public ::google::protobuf::MessageLite {
 public:
  MsgUserRequest_Modify();
  virtual ~MsgUserRequest_Modify();

  MsgUserRequest_Modify(const MsgUserRequest_Modify& from);

  inline MsgUserRequest_Modify& operator=(const MsgUserRequest_Modify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MsgUserRequest_Modify& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MsgUserRequest_Modify* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MsgUserRequest_Modify* other);

  // implements Message ----------------------------------------------

  MsgUserRequest_Modify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MsgUserRequest_Modify& from);
  void MergeFrom(const MsgUserRequest_Modify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string email = 1;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 1;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string address = 3;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 3;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const char* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  inline void set_allocated_address(::std::string* address);

  // optional bytes phone_number = 4;
  inline bool has_phone_number() const;
  inline void clear_phone_number();
  static const int kPhoneNumberFieldNumber = 4;
  inline const ::std::string& phone_number() const;
  inline void set_phone_number(const ::std::string& value);
  inline void set_phone_number(const char* value);
  inline void set_phone_number(const void* value, size_t size);
  inline ::std::string* mutable_phone_number();
  inline ::std::string* release_phone_number();
  inline void set_allocated_phone_number(::std::string* phone_number);

  // optional bytes description = 5;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 5;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const void* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // optional bytes avatar = 6;
  inline bool has_avatar() const;
  inline void clear_avatar();
  static const int kAvatarFieldNumber = 6;
  inline const ::std::string& avatar() const;
  inline void set_avatar(const ::std::string& value);
  inline void set_avatar(const char* value);
  inline void set_avatar(const void* value, size_t size);
  inline ::std::string* mutable_avatar();
  inline ::std::string* release_avatar();
  inline void set_allocated_avatar(::std::string* avatar);

  // @@protoc_insertion_point(class_scope:user.MsgUserRequest.Modify)
 private:
  inline void set_has_email();
  inline void clear_has_email();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_phone_number();
  inline void clear_has_phone_number();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_avatar();
  inline void clear_has_avatar();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* email_;
  ::std::string* name_;
  ::std::string* address_;
  ::std::string* phone_number_;
  ::std::string* description_;
  ::std::string* avatar_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static MsgUserRequest_Modify* default_instance_;
};
// -------------------------------------------------------------------

class MsgUserRequest_Get : public ::google::protobuf::MessageLite {
 public:
  MsgUserRequest_Get();
  virtual ~MsgUserRequest_Get();

  MsgUserRequest_Get(const MsgUserRequest_Get& from);

  inline MsgUserRequest_Get& operator=(const MsgUserRequest_Get& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MsgUserRequest_Get& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MsgUserRequest_Get* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MsgUserRequest_Get* other);

  // implements Message ----------------------------------------------

  MsgUserRequest_Get* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MsgUserRequest_Get& from);
  void MergeFrom(const MsgUserRequest_Get& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool basic_data = 1;
  inline bool has_basic_data() const;
  inline void clear_basic_data();
  static const int kBasicDataFieldNumber = 1;
  inline bool basic_data() const;
  inline void set_basic_data(bool value);

  // optional bool config = 2;
  inline bool has_config() const;
  inline void clear_config();
  static const int kConfigFieldNumber = 2;
  inline bool config() const;
  inline void set_config(bool value);

  // optional bool stats = 3;
  inline bool has_stats() const;
  inline void clear_stats();
  static const int kStatsFieldNumber = 3;
  inline bool stats() const;
  inline void set_stats(bool value);

  // optional bool permissions = 4;
  inline bool has_permissions() const;
  inline void clear_permissions();
  static const int kPermissionsFieldNumber = 4;
  inline bool permissions() const;
  inline void set_permissions(bool value);

  // optional bool details = 5;
  inline bool has_details() const;
  inline void clear_details();
  static const int kDetailsFieldNumber = 5;
  inline bool details() const;
  inline void set_details(bool value);

  // @@protoc_insertion_point(class_scope:user.MsgUserRequest.Get)
 private:
  inline void set_has_basic_data();
  inline void clear_has_basic_data();
  inline void set_has_config();
  inline void clear_has_config();
  inline void set_has_stats();
  inline void clear_has_stats();
  inline void set_has_permissions();
  inline void clear_has_permissions();
  inline void set_has_details();
  inline void clear_has_details();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool basic_data_;
  bool config_;
  bool stats_;
  bool permissions_;
  bool details_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static MsgUserRequest_Get* default_instance_;
};
// -------------------------------------------------------------------

class MsgUserRequest : public ::google::protobuf::MessageLite {
 public:
  MsgUserRequest();
  virtual ~MsgUserRequest();

  MsgUserRequest(const MsgUserRequest& from);

  inline MsgUserRequest& operator=(const MsgUserRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MsgUserRequest& default_instance();

  enum DataCase {
    kAdd = 2,
    kLogin = 3,
    kLogout = 4,
    kRemove = 5,
    kModify = 6,
    kGet = 7,
    DATA_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MsgUserRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MsgUserRequest* other);

  // implements Message ----------------------------------------------

  MsgUserRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MsgUserRequest& from);
  void MergeFrom(const MsgUserRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef MsgUserRequest_Credentials Credentials;
  typedef MsgUserRequest_Login Login;
  typedef MsgUserRequest_Logout Logout;
  typedef MsgUserRequest_Add Add;
  typedef MsgUserRequest_Remove Remove;
  typedef MsgUserRequest_Modify Modify;
  typedef MsgUserRequest_Get Get;

  // accessors -------------------------------------------------------

  // optional .user.Action action = 1;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 1;
  inline ::user::Action action() const;
  inline void set_action(::user::Action value);

  // optional .user.MsgUserRequest.Add add = 2;
  inline bool has_add() const;
  inline void clear_add();
  static const int kAddFieldNumber = 2;
  inline const ::user::MsgUserRequest_Add& add() const;
  inline ::user::MsgUserRequest_Add* mutable_add();
  inline ::user::MsgUserRequest_Add* release_add();
  inline void set_allocated_add(::user::MsgUserRequest_Add* add);

  // optional .user.MsgUserRequest.Login login = 3;
  inline bool has_login() const;
  inline void clear_login();
  static const int kLoginFieldNumber = 3;
  inline const ::user::MsgUserRequest_Login& login() const;
  inline ::user::MsgUserRequest_Login* mutable_login();
  inline ::user::MsgUserRequest_Login* release_login();
  inline void set_allocated_login(::user::MsgUserRequest_Login* login);

  // optional .user.MsgUserRequest.Logout logout = 4;
  inline bool has_logout() const;
  inline void clear_logout();
  static const int kLogoutFieldNumber = 4;
  inline const ::user::MsgUserRequest_Logout& logout() const;
  inline ::user::MsgUserRequest_Logout* mutable_logout();
  inline ::user::MsgUserRequest_Logout* release_logout();
  inline void set_allocated_logout(::user::MsgUserRequest_Logout* logout);

  // optional .user.MsgUserRequest.Remove remove = 5;
  inline bool has_remove() const;
  inline void clear_remove();
  static const int kRemoveFieldNumber = 5;
  inline const ::user::MsgUserRequest_Remove& remove() const;
  inline ::user::MsgUserRequest_Remove* mutable_remove();
  inline ::user::MsgUserRequest_Remove* release_remove();
  inline void set_allocated_remove(::user::MsgUserRequest_Remove* remove);

  // optional .user.MsgUserRequest.Modify modify = 6;
  inline bool has_modify() const;
  inline void clear_modify();
  static const int kModifyFieldNumber = 6;
  inline const ::user::MsgUserRequest_Modify& modify() const;
  inline ::user::MsgUserRequest_Modify* mutable_modify();
  inline ::user::MsgUserRequest_Modify* release_modify();
  inline void set_allocated_modify(::user::MsgUserRequest_Modify* modify);

  // optional .user.MsgUserRequest.Get get = 7;
  inline bool has_get() const;
  inline void clear_get();
  static const int kGetFieldNumber = 7;
  inline const ::user::MsgUserRequest_Get& get() const;
  inline ::user::MsgUserRequest_Get* mutable_get();
  inline ::user::MsgUserRequest_Get* release_get();
  inline void set_allocated_get(::user::MsgUserRequest_Get* get);

  inline DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:user.MsgUserRequest)
 private:
  inline void set_has_action();
  inline void clear_has_action();
  inline void set_has_add();
  inline void set_has_login();
  inline void set_has_logout();
  inline void set_has_remove();
  inline void set_has_modify();
  inline void set_has_get();

  inline bool has_data();
  void clear_data();
  inline void clear_has_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int action_;
  union DataUnion {
    ::user::MsgUserRequest_Add* add_;
    ::user::MsgUserRequest_Login* login_;
    ::user::MsgUserRequest_Logout* logout_;
    ::user::MsgUserRequest_Remove* remove_;
    ::user::MsgUserRequest_Modify* modify_;
    ::user::MsgUserRequest_Get* get_;
  } data_;
  ::google::protobuf::uint32 _oneof_case_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static MsgUserRequest* default_instance_;
};
// -------------------------------------------------------------------

class MsgUserResponse : public ::google::protobuf::MessageLite {
 public:
  MsgUserResponse();
  virtual ~MsgUserResponse();

  MsgUserResponse(const MsgUserResponse& from);

  inline MsgUserResponse& operator=(const MsgUserResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MsgUserResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MsgUserResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MsgUserResponse* other);

  // implements Message ----------------------------------------------

  MsgUserResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MsgUserResponse& from);
  void MergeFrom(const MsgUserResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ResponseCode code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline const ::ResponseCode& code() const;
  inline ::ResponseCode* mutable_code();
  inline ::ResponseCode* release_code();
  inline void set_allocated_code(::ResponseCode* code);

  // @@protoc_insertion_point(class_scope:user.MsgUserResponse)
 private:
  inline void set_has_code();
  inline void clear_has_code();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::ResponseCode* code_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static MsgUserResponse* default_instance_;
};
// -------------------------------------------------------------------

class UserDetails : public ::google::protobuf::MessageLite {
 public:
  UserDetails();
  virtual ~UserDetails();

  UserDetails(const UserDetails& from);

  inline UserDetails& operator=(const UserDetails& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const UserDetails& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserDetails* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserDetails* other);

  // implements Message ----------------------------------------------

  UserDetails* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserDetails& from);
  void MergeFrom(const UserDetails& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string email = 1;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 1;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string address = 3;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 3;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const char* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  inline void set_allocated_address(::std::string* address);

  // optional bytes phone_number = 4;
  inline bool has_phone_number() const;
  inline void clear_phone_number();
  static const int kPhoneNumberFieldNumber = 4;
  inline const ::std::string& phone_number() const;
  inline void set_phone_number(const ::std::string& value);
  inline void set_phone_number(const char* value);
  inline void set_phone_number(const void* value, size_t size);
  inline ::std::string* mutable_phone_number();
  inline ::std::string* release_phone_number();
  inline void set_allocated_phone_number(::std::string* phone_number);

  // optional bytes description = 5;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 5;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const void* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // optional bytes avatar = 6;
  inline bool has_avatar() const;
  inline void clear_avatar();
  static const int kAvatarFieldNumber = 6;
  inline const ::std::string& avatar() const;
  inline void set_avatar(const ::std::string& value);
  inline void set_avatar(const char* value);
  inline void set_avatar(const void* value, size_t size);
  inline ::std::string* mutable_avatar();
  inline ::std::string* release_avatar();
  inline void set_allocated_avatar(::std::string* avatar);

  // @@protoc_insertion_point(class_scope:user.UserDetails)
 private:
  inline void set_has_email();
  inline void clear_has_email();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_phone_number();
  inline void clear_has_phone_number();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_avatar();
  inline void clear_has_avatar();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* email_;
  ::std::string* name_;
  ::std::string* address_;
  ::std::string* phone_number_;
  ::std::string* description_;
  ::std::string* avatar_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static UserDetails* default_instance_;
};
// -------------------------------------------------------------------

class UserConfig : public ::google::protobuf::MessageLite {
 public:
  UserConfig();
  virtual ~UserConfig();

  UserConfig(const UserConfig& from);

  inline UserConfig& operator=(const UserConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const UserConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserConfig* other);

  // implements Message ----------------------------------------------

  UserConfig* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserConfig& from);
  void MergeFrom(const UserConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 last_storage_id = 1;
  inline bool has_last_storage_id() const;
  inline void clear_last_storage_id();
  static const int kLastStorageIdFieldNumber = 1;
  inline ::google::protobuf::uint32 last_storage_id() const;
  inline void set_last_storage_id(::google::protobuf::uint32 value);

  // optional uint32 last_group_id = 2;
  inline bool has_last_group_id() const;
  inline void clear_last_group_id();
  static const int kLastGroupIdFieldNumber = 2;
  inline ::google::protobuf::uint32 last_group_id() const;
  inline void set_last_group_id(::google::protobuf::uint32 value);

  // optional uint32 last_item_id = 3;
  inline bool has_last_item_id() const;
  inline void clear_last_item_id();
  static const int kLastItemIdFieldNumber = 3;
  inline ::google::protobuf::uint32 last_item_id() const;
  inline void set_last_item_id(::google::protobuf::uint32 value);

  // optional uint32 last_parameter_id = 4;
  inline bool has_last_parameter_id() const;
  inline void clear_last_parameter_id();
  static const int kLastParameterIdFieldNumber = 4;
  inline ::google::protobuf::uint32 last_parameter_id() const;
  inline void set_last_parameter_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:user.UserConfig)
 private:
  inline void set_has_last_storage_id();
  inline void clear_has_last_storage_id();
  inline void set_has_last_group_id();
  inline void clear_has_last_group_id();
  inline void set_has_last_item_id();
  inline void clear_has_last_item_id();
  inline void set_has_last_parameter_id();
  inline void clear_has_last_parameter_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 last_storage_id_;
  ::google::protobuf::uint32 last_group_id_;
  ::google::protobuf::uint32 last_item_id_;
  ::google::protobuf::uint32 last_parameter_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static UserConfig* default_instance_;
};
// -------------------------------------------------------------------

class UserStatis : public ::google::protobuf::MessageLite {
 public:
  UserStatis();
  virtual ~UserStatis();

  UserStatis(const UserStatis& from);

  inline UserStatis& operator=(const UserStatis& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const UserStatis& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserStatis* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserStatis* other);

  // implements Message ----------------------------------------------

  UserStatis* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserStatis& from);
  void MergeFrom(const UserStatis& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 magazineCount = 1;
  inline bool has_magazinecount() const;
  inline void clear_magazinecount();
  static const int kMagazineCountFieldNumber = 1;
  inline ::google::protobuf::uint32 magazinecount() const;
  inline void set_magazinecount(::google::protobuf::uint32 value);

  // optional uint32 totalNumOfElements = 2;
  inline bool has_totalnumofelements() const;
  inline void clear_totalnumofelements();
  static const int kTotalNumOfElementsFieldNumber = 2;
  inline ::google::protobuf::uint32 totalnumofelements() const;
  inline void set_totalnumofelements(::google::protobuf::uint32 value);

  // optional uint32 totalNumOfUniqueElements = 3;
  inline bool has_totalnumofuniqueelements() const;
  inline void clear_totalnumofuniqueelements();
  static const int kTotalNumOfUniqueElementsFieldNumber = 3;
  inline ::google::protobuf::uint32 totalnumofuniqueelements() const;
  inline void set_totalnumofuniqueelements(::google::protobuf::uint32 value);

  // optional uint32 totalNumOfRequests = 4;
  inline bool has_totalnumofrequests() const;
  inline void clear_totalnumofrequests();
  static const int kTotalNumOfRequestsFieldNumber = 4;
  inline ::google::protobuf::uint32 totalnumofrequests() const;
  inline void set_totalnumofrequests(::google::protobuf::uint32 value);

  // optional uint32 totalModifiedItems = 5;
  inline bool has_totalmodifieditems() const;
  inline void clear_totalmodifieditems();
  static const int kTotalModifiedItemsFieldNumber = 5;
  inline ::google::protobuf::uint32 totalmodifieditems() const;
  inline void set_totalmodifieditems(::google::protobuf::uint32 value);

  // optional uint32 totalAddItems = 6;
  inline bool has_totaladditems() const;
  inline void clear_totaladditems();
  static const int kTotalAddItemsFieldNumber = 6;
  inline ::google::protobuf::uint32 totaladditems() const;
  inline void set_totaladditems(::google::protobuf::uint32 value);

  // optional fixed64 last_login = 7;
  inline bool has_last_login() const;
  inline void clear_last_login();
  static const int kLastLoginFieldNumber = 7;
  inline ::google::protobuf::uint64 last_login() const;
  inline void set_last_login(::google::protobuf::uint64 value);

  // optional fixed64 registration_date = 8;
  inline bool has_registration_date() const;
  inline void clear_registration_date();
  static const int kRegistrationDateFieldNumber = 8;
  inline ::google::protobuf::uint64 registration_date() const;
  inline void set_registration_date(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:user.UserStatis)
 private:
  inline void set_has_magazinecount();
  inline void clear_has_magazinecount();
  inline void set_has_totalnumofelements();
  inline void clear_has_totalnumofelements();
  inline void set_has_totalnumofuniqueelements();
  inline void clear_has_totalnumofuniqueelements();
  inline void set_has_totalnumofrequests();
  inline void clear_has_totalnumofrequests();
  inline void set_has_totalmodifieditems();
  inline void clear_has_totalmodifieditems();
  inline void set_has_totaladditems();
  inline void clear_has_totaladditems();
  inline void set_has_last_login();
  inline void clear_has_last_login();
  inline void set_has_registration_date();
  inline void clear_has_registration_date();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 magazinecount_;
  ::google::protobuf::uint32 totalnumofelements_;
  ::google::protobuf::uint32 totalnumofuniqueelements_;
  ::google::protobuf::uint32 totalnumofrequests_;
  ::google::protobuf::uint32 totalmodifieditems_;
  ::google::protobuf::uint32 totaladditems_;
  ::google::protobuf::uint64 last_login_;
  ::google::protobuf::uint64 registration_date_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static UserStatis* default_instance_;
};
// ===================================================================


// ===================================================================

// MsgUserRequest_Credentials

// optional uint32 id = 1;
inline bool MsgUserRequest_Credentials::has_id() const {
  return login_id_case() == kId;
}
inline void MsgUserRequest_Credentials::set_has_id() {
  _oneof_case_[0] = kId;
}
inline void MsgUserRequest_Credentials::clear_id() {
  if (has_id()) {
    login_id_.id_ = 0u;
    clear_has_login_id();
  }
}
inline ::google::protobuf::uint32 MsgUserRequest_Credentials::id() const {
  if (has_id()) {
    return login_id_.id_;
  }
  return 0u;
}
inline void MsgUserRequest_Credentials::set_id(::google::protobuf::uint32 value) {
  if (!has_id()) {
    clear_login_id();
    set_has_id();
  }
  login_id_.id_ = value;
}

// optional string name = 2;
inline bool MsgUserRequest_Credentials::has_name() const {
  return login_id_case() == kName;
}
inline void MsgUserRequest_Credentials::set_has_name() {
  _oneof_case_[0] = kName;
}
inline void MsgUserRequest_Credentials::clear_name() {
  if (has_name()) {
    delete login_id_.name_;
    clear_has_login_id();
  }
}
inline const ::std::string& MsgUserRequest_Credentials::name() const {
  if (has_name()) {
    return *login_id_.name_;
  }
  return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void MsgUserRequest_Credentials::set_name(const ::std::string& value) {
  if (!has_name()) {
    clear_login_id();
    set_has_name();
    login_id_.name_ = new ::std::string;
  }
  login_id_.name_->assign(value);
}
inline void MsgUserRequest_Credentials::set_name(const char* value) {
  if (!has_name()) {
    clear_login_id();
    set_has_name();
    login_id_.name_ = new ::std::string;
  }
  login_id_.name_->assign(value);
}
inline void MsgUserRequest_Credentials::set_name(const char* value, size_t size) {
  if (!has_name()) {
    clear_login_id();
    set_has_name();
    login_id_.name_ = new ::std::string;
  }
  login_id_.name_->assign(
      reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgUserRequest_Credentials::mutable_name() {
  if (!has_name()) {
    clear_login_id();
    set_has_name();
    login_id_.name_ = new ::std::string;
  }
  return login_id_.name_;
}
inline ::std::string* MsgUserRequest_Credentials::release_name() {
  if (has_name()) {
    clear_has_login_id();
    ::std::string* temp = login_id_.name_;
    login_id_.name_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MsgUserRequest_Credentials::set_allocated_name(::std::string* name) {
  clear_login_id();
  if (name) {
    set_has_name();
    login_id_.name_ = name;
  }
}

// optional string email = 3;
inline bool MsgUserRequest_Credentials::has_email() const {
  return login_id_case() == kEmail;
}
inline void MsgUserRequest_Credentials::set_has_email() {
  _oneof_case_[0] = kEmail;
}
inline void MsgUserRequest_Credentials::clear_email() {
  if (has_email()) {
    delete login_id_.email_;
    clear_has_login_id();
  }
}
inline const ::std::string& MsgUserRequest_Credentials::email() const {
  if (has_email()) {
    return *login_id_.email_;
  }
  return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void MsgUserRequest_Credentials::set_email(const ::std::string& value) {
  if (!has_email()) {
    clear_login_id();
    set_has_email();
    login_id_.email_ = new ::std::string;
  }
  login_id_.email_->assign(value);
}
inline void MsgUserRequest_Credentials::set_email(const char* value) {
  if (!has_email()) {
    clear_login_id();
    set_has_email();
    login_id_.email_ = new ::std::string;
  }
  login_id_.email_->assign(value);
}
inline void MsgUserRequest_Credentials::set_email(const char* value, size_t size) {
  if (!has_email()) {
    clear_login_id();
    set_has_email();
    login_id_.email_ = new ::std::string;
  }
  login_id_.email_->assign(
      reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgUserRequest_Credentials::mutable_email() {
  if (!has_email()) {
    clear_login_id();
    set_has_email();
    login_id_.email_ = new ::std::string;
  }
  return login_id_.email_;
}
inline ::std::string* MsgUserRequest_Credentials::release_email() {
  if (has_email()) {
    clear_has_login_id();
    ::std::string* temp = login_id_.email_;
    login_id_.email_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MsgUserRequest_Credentials::set_allocated_email(::std::string* email) {
  clear_login_id();
  if (email) {
    set_has_email();
    login_id_.email_ = email;
  }
}

inline bool MsgUserRequest_Credentials::has_login_id() {
  return login_id_case() != LOGIN_ID_NOT_SET;
}
inline void MsgUserRequest_Credentials::clear_has_login_id() {
  _oneof_case_[0] = LOGIN_ID_NOT_SET;
}
inline MsgUserRequest_Credentials::LoginIdCase MsgUserRequest_Credentials::login_id_case() const {
  return MsgUserRequest_Credentials::LoginIdCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// MsgUserRequest_Login

// required .user.MsgUserRequest.Credentials cred = 1;
inline bool MsgUserRequest_Login::has_cred() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgUserRequest_Login::set_has_cred() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgUserRequest_Login::clear_has_cred() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgUserRequest_Login::clear_cred() {
  if (cred_ != NULL) cred_->::user::MsgUserRequest_Credentials::Clear();
  clear_has_cred();
}
inline const ::user::MsgUserRequest_Credentials& MsgUserRequest_Login::cred() const {
  // @@protoc_insertion_point(field_get:user.MsgUserRequest.Login.cred)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return cred_ != NULL ? *cred_ : *default_instance().cred_;
#else
  return cred_ != NULL ? *cred_ : *default_instance_->cred_;
#endif
}
inline ::user::MsgUserRequest_Credentials* MsgUserRequest_Login::mutable_cred() {
  set_has_cred();
  if (cred_ == NULL) cred_ = new ::user::MsgUserRequest_Credentials;
  // @@protoc_insertion_point(field_mutable:user.MsgUserRequest.Login.cred)
  return cred_;
}
inline ::user::MsgUserRequest_Credentials* MsgUserRequest_Login::release_cred() {
  clear_has_cred();
  ::user::MsgUserRequest_Credentials* temp = cred_;
  cred_ = NULL;
  return temp;
}
inline void MsgUserRequest_Login::set_allocated_cred(::user::MsgUserRequest_Credentials* cred) {
  delete cred_;
  cred_ = cred;
  if (cred) {
    set_has_cred();
  } else {
    clear_has_cred();
  }
  // @@protoc_insertion_point(field_set_allocated:user.MsgUserRequest.Login.cred)
}

// required string password = 2;
inline bool MsgUserRequest_Login::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgUserRequest_Login::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgUserRequest_Login::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgUserRequest_Login::clear_password() {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& MsgUserRequest_Login::password() const {
  // @@protoc_insertion_point(field_get:user.MsgUserRequest.Login.password)
  return *password_;
}
inline void MsgUserRequest_Login::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set:user.MsgUserRequest.Login.password)
}
inline void MsgUserRequest_Login::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set_char:user.MsgUserRequest.Login.password)
}
inline void MsgUserRequest_Login::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:user.MsgUserRequest.Login.password)
}
inline ::std::string* MsgUserRequest_Login::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:user.MsgUserRequest.Login.password)
  return password_;
}
inline ::std::string* MsgUserRequest_Login::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MsgUserRequest_Login::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:user.MsgUserRequest.Login.password)
}

// -------------------------------------------------------------------

// MsgUserRequest_Logout

// -------------------------------------------------------------------

// MsgUserRequest_Add

// required .user.UserDetails details = 1;
inline bool MsgUserRequest_Add::has_details() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgUserRequest_Add::set_has_details() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgUserRequest_Add::clear_has_details() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgUserRequest_Add::clear_details() {
  if (details_ != NULL) details_->::user::UserDetails::Clear();
  clear_has_details();
}
inline const ::user::UserDetails& MsgUserRequest_Add::details() const {
  // @@protoc_insertion_point(field_get:user.MsgUserRequest.Add.details)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return details_ != NULL ? *details_ : *default_instance().details_;
#else
  return details_ != NULL ? *details_ : *default_instance_->details_;
#endif
}
inline ::user::UserDetails* MsgUserRequest_Add::mutable_details() {
  set_has_details();
  if (details_ == NULL) details_ = new ::user::UserDetails;
  // @@protoc_insertion_point(field_mutable:user.MsgUserRequest.Add.details)
  return details_;
}
inline ::user::UserDetails* MsgUserRequest_Add::release_details() {
  clear_has_details();
  ::user::UserDetails* temp = details_;
  details_ = NULL;
  return temp;
}
inline void MsgUserRequest_Add::set_allocated_details(::user::UserDetails* details) {
  delete details_;
  details_ = details;
  if (details) {
    set_has_details();
  } else {
    clear_has_details();
  }
  // @@protoc_insertion_point(field_set_allocated:user.MsgUserRequest.Add.details)
}

// optional .user.UserConfig config = 2;
inline bool MsgUserRequest_Add::has_config() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgUserRequest_Add::set_has_config() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgUserRequest_Add::clear_has_config() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgUserRequest_Add::clear_config() {
  if (config_ != NULL) config_->::user::UserConfig::Clear();
  clear_has_config();
}
inline const ::user::UserConfig& MsgUserRequest_Add::config() const {
  // @@protoc_insertion_point(field_get:user.MsgUserRequest.Add.config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return config_ != NULL ? *config_ : *default_instance().config_;
#else
  return config_ != NULL ? *config_ : *default_instance_->config_;
#endif
}
inline ::user::UserConfig* MsgUserRequest_Add::mutable_config() {
  set_has_config();
  if (config_ == NULL) config_ = new ::user::UserConfig;
  // @@protoc_insertion_point(field_mutable:user.MsgUserRequest.Add.config)
  return config_;
}
inline ::user::UserConfig* MsgUserRequest_Add::release_config() {
  clear_has_config();
  ::user::UserConfig* temp = config_;
  config_ = NULL;
  return temp;
}
inline void MsgUserRequest_Add::set_allocated_config(::user::UserConfig* config) {
  delete config_;
  config_ = config;
  if (config) {
    set_has_config();
  } else {
    clear_has_config();
  }
  // @@protoc_insertion_point(field_set_allocated:user.MsgUserRequest.Add.config)
}

// optional string password = 3;
inline bool MsgUserRequest_Add::has_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgUserRequest_Add::set_has_password() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgUserRequest_Add::clear_has_password() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgUserRequest_Add::clear_password() {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& MsgUserRequest_Add::password() const {
  // @@protoc_insertion_point(field_get:user.MsgUserRequest.Add.password)
  return *password_;
}
inline void MsgUserRequest_Add::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set:user.MsgUserRequest.Add.password)
}
inline void MsgUserRequest_Add::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set_char:user.MsgUserRequest.Add.password)
}
inline void MsgUserRequest_Add::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:user.MsgUserRequest.Add.password)
}
inline ::std::string* MsgUserRequest_Add::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:user.MsgUserRequest.Add.password)
  return password_;
}
inline ::std::string* MsgUserRequest_Add::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MsgUserRequest_Add::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:user.MsgUserRequest.Add.password)
}

// -------------------------------------------------------------------

// MsgUserRequest_Remove

// required .user.MsgUserRequest.Credentials cred = 1;
inline bool MsgUserRequest_Remove::has_cred() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgUserRequest_Remove::set_has_cred() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgUserRequest_Remove::clear_has_cred() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgUserRequest_Remove::clear_cred() {
  if (cred_ != NULL) cred_->::user::MsgUserRequest_Credentials::Clear();
  clear_has_cred();
}
inline const ::user::MsgUserRequest_Credentials& MsgUserRequest_Remove::cred() const {
  // @@protoc_insertion_point(field_get:user.MsgUserRequest.Remove.cred)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return cred_ != NULL ? *cred_ : *default_instance().cred_;
#else
  return cred_ != NULL ? *cred_ : *default_instance_->cred_;
#endif
}
inline ::user::MsgUserRequest_Credentials* MsgUserRequest_Remove::mutable_cred() {
  set_has_cred();
  if (cred_ == NULL) cred_ = new ::user::MsgUserRequest_Credentials;
  // @@protoc_insertion_point(field_mutable:user.MsgUserRequest.Remove.cred)
  return cred_;
}
inline ::user::MsgUserRequest_Credentials* MsgUserRequest_Remove::release_cred() {
  clear_has_cred();
  ::user::MsgUserRequest_Credentials* temp = cred_;
  cred_ = NULL;
  return temp;
}
inline void MsgUserRequest_Remove::set_allocated_cred(::user::MsgUserRequest_Credentials* cred) {
  delete cred_;
  cred_ = cred;
  if (cred) {
    set_has_cred();
  } else {
    clear_has_cred();
  }
  // @@protoc_insertion_point(field_set_allocated:user.MsgUserRequest.Remove.cred)
}

// -------------------------------------------------------------------

// MsgUserRequest_Modify

// optional string email = 1;
inline bool MsgUserRequest_Modify::has_email() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgUserRequest_Modify::set_has_email() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgUserRequest_Modify::clear_has_email() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgUserRequest_Modify::clear_email() {
  if (email_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& MsgUserRequest_Modify::email() const {
  // @@protoc_insertion_point(field_get:user.MsgUserRequest.Modify.email)
  return *email_;
}
inline void MsgUserRequest_Modify::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_ = new ::std::string;
  }
  email_->assign(value);
  // @@protoc_insertion_point(field_set:user.MsgUserRequest.Modify.email)
}
inline void MsgUserRequest_Modify::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_ = new ::std::string;
  }
  email_->assign(value);
  // @@protoc_insertion_point(field_set_char:user.MsgUserRequest.Modify.email)
}
inline void MsgUserRequest_Modify::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:user.MsgUserRequest.Modify.email)
}
inline ::std::string* MsgUserRequest_Modify::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:user.MsgUserRequest.Modify.email)
  return email_;
}
inline ::std::string* MsgUserRequest_Modify::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MsgUserRequest_Modify::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:user.MsgUserRequest.Modify.email)
}

// optional string name = 2;
inline bool MsgUserRequest_Modify::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgUserRequest_Modify::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgUserRequest_Modify::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgUserRequest_Modify::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& MsgUserRequest_Modify::name() const {
  // @@protoc_insertion_point(field_get:user.MsgUserRequest.Modify.name)
  return *name_;
}
inline void MsgUserRequest_Modify::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:user.MsgUserRequest.Modify.name)
}
inline void MsgUserRequest_Modify::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:user.MsgUserRequest.Modify.name)
}
inline void MsgUserRequest_Modify::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:user.MsgUserRequest.Modify.name)
}
inline ::std::string* MsgUserRequest_Modify::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:user.MsgUserRequest.Modify.name)
  return name_;
}
inline ::std::string* MsgUserRequest_Modify::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MsgUserRequest_Modify::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:user.MsgUserRequest.Modify.name)
}

// optional string address = 3;
inline bool MsgUserRequest_Modify::has_address() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgUserRequest_Modify::set_has_address() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgUserRequest_Modify::clear_has_address() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgUserRequest_Modify::clear_address() {
  if (address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& MsgUserRequest_Modify::address() const {
  // @@protoc_insertion_point(field_get:user.MsgUserRequest.Modify.address)
  return *address_;
}
inline void MsgUserRequest_Modify::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  address_->assign(value);
  // @@protoc_insertion_point(field_set:user.MsgUserRequest.Modify.address)
}
inline void MsgUserRequest_Modify::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  address_->assign(value);
  // @@protoc_insertion_point(field_set_char:user.MsgUserRequest.Modify.address)
}
inline void MsgUserRequest_Modify::set_address(const char* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:user.MsgUserRequest.Modify.address)
}
inline ::std::string* MsgUserRequest_Modify::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:user.MsgUserRequest.Modify.address)
  return address_;
}
inline ::std::string* MsgUserRequest_Modify::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MsgUserRequest_Modify::set_allocated_address(::std::string* address) {
  if (address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete address_;
  }
  if (address) {
    set_has_address();
    address_ = address;
  } else {
    clear_has_address();
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:user.MsgUserRequest.Modify.address)
}

// optional bytes phone_number = 4;
inline bool MsgUserRequest_Modify::has_phone_number() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MsgUserRequest_Modify::set_has_phone_number() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MsgUserRequest_Modify::clear_has_phone_number() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MsgUserRequest_Modify::clear_phone_number() {
  if (phone_number_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phone_number_->clear();
  }
  clear_has_phone_number();
}
inline const ::std::string& MsgUserRequest_Modify::phone_number() const {
  // @@protoc_insertion_point(field_get:user.MsgUserRequest.Modify.phone_number)
  return *phone_number_;
}
inline void MsgUserRequest_Modify::set_phone_number(const ::std::string& value) {
  set_has_phone_number();
  if (phone_number_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phone_number_ = new ::std::string;
  }
  phone_number_->assign(value);
  // @@protoc_insertion_point(field_set:user.MsgUserRequest.Modify.phone_number)
}
inline void MsgUserRequest_Modify::set_phone_number(const char* value) {
  set_has_phone_number();
  if (phone_number_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phone_number_ = new ::std::string;
  }
  phone_number_->assign(value);
  // @@protoc_insertion_point(field_set_char:user.MsgUserRequest.Modify.phone_number)
}
inline void MsgUserRequest_Modify::set_phone_number(const void* value, size_t size) {
  set_has_phone_number();
  if (phone_number_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phone_number_ = new ::std::string;
  }
  phone_number_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:user.MsgUserRequest.Modify.phone_number)
}
inline ::std::string* MsgUserRequest_Modify::mutable_phone_number() {
  set_has_phone_number();
  if (phone_number_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phone_number_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:user.MsgUserRequest.Modify.phone_number)
  return phone_number_;
}
inline ::std::string* MsgUserRequest_Modify::release_phone_number() {
  clear_has_phone_number();
  if (phone_number_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = phone_number_;
    phone_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MsgUserRequest_Modify::set_allocated_phone_number(::std::string* phone_number) {
  if (phone_number_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete phone_number_;
  }
  if (phone_number) {
    set_has_phone_number();
    phone_number_ = phone_number;
  } else {
    clear_has_phone_number();
    phone_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:user.MsgUserRequest.Modify.phone_number)
}

// optional bytes description = 5;
inline bool MsgUserRequest_Modify::has_description() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MsgUserRequest_Modify::set_has_description() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MsgUserRequest_Modify::clear_has_description() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MsgUserRequest_Modify::clear_description() {
  if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& MsgUserRequest_Modify::description() const {
  // @@protoc_insertion_point(field_get:user.MsgUserRequest.Modify.description)
  return *description_;
}
inline void MsgUserRequest_Modify::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(value);
  // @@protoc_insertion_point(field_set:user.MsgUserRequest.Modify.description)
}
inline void MsgUserRequest_Modify::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(value);
  // @@protoc_insertion_point(field_set_char:user.MsgUserRequest.Modify.description)
}
inline void MsgUserRequest_Modify::set_description(const void* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:user.MsgUserRequest.Modify.description)
}
inline ::std::string* MsgUserRequest_Modify::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:user.MsgUserRequest.Modify.description)
  return description_;
}
inline ::std::string* MsgUserRequest_Modify::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MsgUserRequest_Modify::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:user.MsgUserRequest.Modify.description)
}

// optional bytes avatar = 6;
inline bool MsgUserRequest_Modify::has_avatar() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MsgUserRequest_Modify::set_has_avatar() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MsgUserRequest_Modify::clear_has_avatar() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MsgUserRequest_Modify::clear_avatar() {
  if (avatar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_->clear();
  }
  clear_has_avatar();
}
inline const ::std::string& MsgUserRequest_Modify::avatar() const {
  // @@protoc_insertion_point(field_get:user.MsgUserRequest.Modify.avatar)
  return *avatar_;
}
inline void MsgUserRequest_Modify::set_avatar(const ::std::string& value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
  // @@protoc_insertion_point(field_set:user.MsgUserRequest.Modify.avatar)
}
inline void MsgUserRequest_Modify::set_avatar(const char* value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
  // @@protoc_insertion_point(field_set_char:user.MsgUserRequest.Modify.avatar)
}
inline void MsgUserRequest_Modify::set_avatar(const void* value, size_t size) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:user.MsgUserRequest.Modify.avatar)
}
inline ::std::string* MsgUserRequest_Modify::mutable_avatar() {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:user.MsgUserRequest.Modify.avatar)
  return avatar_;
}
inline ::std::string* MsgUserRequest_Modify::release_avatar() {
  clear_has_avatar();
  if (avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = avatar_;
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MsgUserRequest_Modify::set_allocated_avatar(::std::string* avatar) {
  if (avatar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete avatar_;
  }
  if (avatar) {
    set_has_avatar();
    avatar_ = avatar;
  } else {
    clear_has_avatar();
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:user.MsgUserRequest.Modify.avatar)
}

// -------------------------------------------------------------------

// MsgUserRequest_Get

// optional bool basic_data = 1;
inline bool MsgUserRequest_Get::has_basic_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgUserRequest_Get::set_has_basic_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgUserRequest_Get::clear_has_basic_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgUserRequest_Get::clear_basic_data() {
  basic_data_ = false;
  clear_has_basic_data();
}
inline bool MsgUserRequest_Get::basic_data() const {
  // @@protoc_insertion_point(field_get:user.MsgUserRequest.Get.basic_data)
  return basic_data_;
}
inline void MsgUserRequest_Get::set_basic_data(bool value) {
  set_has_basic_data();
  basic_data_ = value;
  // @@protoc_insertion_point(field_set:user.MsgUserRequest.Get.basic_data)
}

// optional bool config = 2;
inline bool MsgUserRequest_Get::has_config() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgUserRequest_Get::set_has_config() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgUserRequest_Get::clear_has_config() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgUserRequest_Get::clear_config() {
  config_ = false;
  clear_has_config();
}
inline bool MsgUserRequest_Get::config() const {
  // @@protoc_insertion_point(field_get:user.MsgUserRequest.Get.config)
  return config_;
}
inline void MsgUserRequest_Get::set_config(bool value) {
  set_has_config();
  config_ = value;
  // @@protoc_insertion_point(field_set:user.MsgUserRequest.Get.config)
}

// optional bool stats = 3;
inline bool MsgUserRequest_Get::has_stats() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgUserRequest_Get::set_has_stats() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgUserRequest_Get::clear_has_stats() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgUserRequest_Get::clear_stats() {
  stats_ = false;
  clear_has_stats();
}
inline bool MsgUserRequest_Get::stats() const {
  // @@protoc_insertion_point(field_get:user.MsgUserRequest.Get.stats)
  return stats_;
}
inline void MsgUserRequest_Get::set_stats(bool value) {
  set_has_stats();
  stats_ = value;
  // @@protoc_insertion_point(field_set:user.MsgUserRequest.Get.stats)
}

// optional bool permissions = 4;
inline bool MsgUserRequest_Get::has_permissions() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MsgUserRequest_Get::set_has_permissions() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MsgUserRequest_Get::clear_has_permissions() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MsgUserRequest_Get::clear_permissions() {
  permissions_ = false;
  clear_has_permissions();
}
inline bool MsgUserRequest_Get::permissions() const {
  // @@protoc_insertion_point(field_get:user.MsgUserRequest.Get.permissions)
  return permissions_;
}
inline void MsgUserRequest_Get::set_permissions(bool value) {
  set_has_permissions();
  permissions_ = value;
  // @@protoc_insertion_point(field_set:user.MsgUserRequest.Get.permissions)
}

// optional bool details = 5;
inline bool MsgUserRequest_Get::has_details() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MsgUserRequest_Get::set_has_details() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MsgUserRequest_Get::clear_has_details() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MsgUserRequest_Get::clear_details() {
  details_ = false;
  clear_has_details();
}
inline bool MsgUserRequest_Get::details() const {
  // @@protoc_insertion_point(field_get:user.MsgUserRequest.Get.details)
  return details_;
}
inline void MsgUserRequest_Get::set_details(bool value) {
  set_has_details();
  details_ = value;
  // @@protoc_insertion_point(field_set:user.MsgUserRequest.Get.details)
}

// -------------------------------------------------------------------

// MsgUserRequest

// optional .user.Action action = 1;
inline bool MsgUserRequest::has_action() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgUserRequest::set_has_action() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgUserRequest::clear_has_action() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgUserRequest::clear_action() {
  action_ = 1;
  clear_has_action();
}
inline ::user::Action MsgUserRequest::action() const {
  // @@protoc_insertion_point(field_get:user.MsgUserRequest.action)
  return static_cast< ::user::Action >(action_);
}
inline void MsgUserRequest::set_action(::user::Action value) {
  assert(::user::Action_IsValid(value));
  set_has_action();
  action_ = value;
  // @@protoc_insertion_point(field_set:user.MsgUserRequest.action)
}

// optional .user.MsgUserRequest.Add add = 2;
inline bool MsgUserRequest::has_add() const {
  return data_case() == kAdd;
}
inline void MsgUserRequest::set_has_add() {
  _oneof_case_[0] = kAdd;
}
inline void MsgUserRequest::clear_add() {
  if (has_add()) {
    delete data_.add_;
    clear_has_data();
  }
}
inline const ::user::MsgUserRequest_Add& MsgUserRequest::add() const {
  return has_add() ? *data_.add_
                      : ::user::MsgUserRequest_Add::default_instance();
}
inline ::user::MsgUserRequest_Add* MsgUserRequest::mutable_add() {
  if (!has_add()) {
    clear_data();
    set_has_add();
    data_.add_ = new ::user::MsgUserRequest_Add;
  }
  return data_.add_;
}
inline ::user::MsgUserRequest_Add* MsgUserRequest::release_add() {
  if (has_add()) {
    clear_has_data();
    ::user::MsgUserRequest_Add* temp = data_.add_;
    data_.add_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MsgUserRequest::set_allocated_add(::user::MsgUserRequest_Add* add) {
  clear_data();
  if (add) {
    set_has_add();
    data_.add_ = add;
  }
}

// optional .user.MsgUserRequest.Login login = 3;
inline bool MsgUserRequest::has_login() const {
  return data_case() == kLogin;
}
inline void MsgUserRequest::set_has_login() {
  _oneof_case_[0] = kLogin;
}
inline void MsgUserRequest::clear_login() {
  if (has_login()) {
    delete data_.login_;
    clear_has_data();
  }
}
inline const ::user::MsgUserRequest_Login& MsgUserRequest::login() const {
  return has_login() ? *data_.login_
                      : ::user::MsgUserRequest_Login::default_instance();
}
inline ::user::MsgUserRequest_Login* MsgUserRequest::mutable_login() {
  if (!has_login()) {
    clear_data();
    set_has_login();
    data_.login_ = new ::user::MsgUserRequest_Login;
  }
  return data_.login_;
}
inline ::user::MsgUserRequest_Login* MsgUserRequest::release_login() {
  if (has_login()) {
    clear_has_data();
    ::user::MsgUserRequest_Login* temp = data_.login_;
    data_.login_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MsgUserRequest::set_allocated_login(::user::MsgUserRequest_Login* login) {
  clear_data();
  if (login) {
    set_has_login();
    data_.login_ = login;
  }
}

// optional .user.MsgUserRequest.Logout logout = 4;
inline bool MsgUserRequest::has_logout() const {
  return data_case() == kLogout;
}
inline void MsgUserRequest::set_has_logout() {
  _oneof_case_[0] = kLogout;
}
inline void MsgUserRequest::clear_logout() {
  if (has_logout()) {
    delete data_.logout_;
    clear_has_data();
  }
}
inline const ::user::MsgUserRequest_Logout& MsgUserRequest::logout() const {
  return has_logout() ? *data_.logout_
                      : ::user::MsgUserRequest_Logout::default_instance();
}
inline ::user::MsgUserRequest_Logout* MsgUserRequest::mutable_logout() {
  if (!has_logout()) {
    clear_data();
    set_has_logout();
    data_.logout_ = new ::user::MsgUserRequest_Logout;
  }
  return data_.logout_;
}
inline ::user::MsgUserRequest_Logout* MsgUserRequest::release_logout() {
  if (has_logout()) {
    clear_has_data();
    ::user::MsgUserRequest_Logout* temp = data_.logout_;
    data_.logout_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MsgUserRequest::set_allocated_logout(::user::MsgUserRequest_Logout* logout) {
  clear_data();
  if (logout) {
    set_has_logout();
    data_.logout_ = logout;
  }
}

// optional .user.MsgUserRequest.Remove remove = 5;
inline bool MsgUserRequest::has_remove() const {
  return data_case() == kRemove;
}
inline void MsgUserRequest::set_has_remove() {
  _oneof_case_[0] = kRemove;
}
inline void MsgUserRequest::clear_remove() {
  if (has_remove()) {
    delete data_.remove_;
    clear_has_data();
  }
}
inline const ::user::MsgUserRequest_Remove& MsgUserRequest::remove() const {
  return has_remove() ? *data_.remove_
                      : ::user::MsgUserRequest_Remove::default_instance();
}
inline ::user::MsgUserRequest_Remove* MsgUserRequest::mutable_remove() {
  if (!has_remove()) {
    clear_data();
    set_has_remove();
    data_.remove_ = new ::user::MsgUserRequest_Remove;
  }
  return data_.remove_;
}
inline ::user::MsgUserRequest_Remove* MsgUserRequest::release_remove() {
  if (has_remove()) {
    clear_has_data();
    ::user::MsgUserRequest_Remove* temp = data_.remove_;
    data_.remove_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MsgUserRequest::set_allocated_remove(::user::MsgUserRequest_Remove* remove) {
  clear_data();
  if (remove) {
    set_has_remove();
    data_.remove_ = remove;
  }
}

// optional .user.MsgUserRequest.Modify modify = 6;
inline bool MsgUserRequest::has_modify() const {
  return data_case() == kModify;
}
inline void MsgUserRequest::set_has_modify() {
  _oneof_case_[0] = kModify;
}
inline void MsgUserRequest::clear_modify() {
  if (has_modify()) {
    delete data_.modify_;
    clear_has_data();
  }
}
inline const ::user::MsgUserRequest_Modify& MsgUserRequest::modify() const {
  return has_modify() ? *data_.modify_
                      : ::user::MsgUserRequest_Modify::default_instance();
}
inline ::user::MsgUserRequest_Modify* MsgUserRequest::mutable_modify() {
  if (!has_modify()) {
    clear_data();
    set_has_modify();
    data_.modify_ = new ::user::MsgUserRequest_Modify;
  }
  return data_.modify_;
}
inline ::user::MsgUserRequest_Modify* MsgUserRequest::release_modify() {
  if (has_modify()) {
    clear_has_data();
    ::user::MsgUserRequest_Modify* temp = data_.modify_;
    data_.modify_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MsgUserRequest::set_allocated_modify(::user::MsgUserRequest_Modify* modify) {
  clear_data();
  if (modify) {
    set_has_modify();
    data_.modify_ = modify;
  }
}

// optional .user.MsgUserRequest.Get get = 7;
inline bool MsgUserRequest::has_get() const {
  return data_case() == kGet;
}
inline void MsgUserRequest::set_has_get() {
  _oneof_case_[0] = kGet;
}
inline void MsgUserRequest::clear_get() {
  if (has_get()) {
    delete data_.get_;
    clear_has_data();
  }
}
inline const ::user::MsgUserRequest_Get& MsgUserRequest::get() const {
  return has_get() ? *data_.get_
                      : ::user::MsgUserRequest_Get::default_instance();
}
inline ::user::MsgUserRequest_Get* MsgUserRequest::mutable_get() {
  if (!has_get()) {
    clear_data();
    set_has_get();
    data_.get_ = new ::user::MsgUserRequest_Get;
  }
  return data_.get_;
}
inline ::user::MsgUserRequest_Get* MsgUserRequest::release_get() {
  if (has_get()) {
    clear_has_data();
    ::user::MsgUserRequest_Get* temp = data_.get_;
    data_.get_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MsgUserRequest::set_allocated_get(::user::MsgUserRequest_Get* get) {
  clear_data();
  if (get) {
    set_has_get();
    data_.get_ = get;
  }
}

inline bool MsgUserRequest::has_data() {
  return data_case() != DATA_NOT_SET;
}
inline void MsgUserRequest::clear_has_data() {
  _oneof_case_[0] = DATA_NOT_SET;
}
inline MsgUserRequest::DataCase MsgUserRequest::data_case() const {
  return MsgUserRequest::DataCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// MsgUserResponse

// required .ResponseCode code = 1;
inline bool MsgUserResponse::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgUserResponse::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgUserResponse::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgUserResponse::clear_code() {
  if (code_ != NULL) code_->::ResponseCode::Clear();
  clear_has_code();
}
inline const ::ResponseCode& MsgUserResponse::code() const {
  // @@protoc_insertion_point(field_get:user.MsgUserResponse.code)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return code_ != NULL ? *code_ : *default_instance().code_;
#else
  return code_ != NULL ? *code_ : *default_instance_->code_;
#endif
}
inline ::ResponseCode* MsgUserResponse::mutable_code() {
  set_has_code();
  if (code_ == NULL) code_ = new ::ResponseCode;
  // @@protoc_insertion_point(field_mutable:user.MsgUserResponse.code)
  return code_;
}
inline ::ResponseCode* MsgUserResponse::release_code() {
  clear_has_code();
  ::ResponseCode* temp = code_;
  code_ = NULL;
  return temp;
}
inline void MsgUserResponse::set_allocated_code(::ResponseCode* code) {
  delete code_;
  code_ = code;
  if (code) {
    set_has_code();
  } else {
    clear_has_code();
  }
  // @@protoc_insertion_point(field_set_allocated:user.MsgUserResponse.code)
}

// -------------------------------------------------------------------

// UserDetails

// required string email = 1;
inline bool UserDetails::has_email() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserDetails::set_has_email() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserDetails::clear_has_email() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserDetails::clear_email() {
  if (email_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& UserDetails::email() const {
  // @@protoc_insertion_point(field_get:user.UserDetails.email)
  return *email_;
}
inline void UserDetails::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_ = new ::std::string;
  }
  email_->assign(value);
  // @@protoc_insertion_point(field_set:user.UserDetails.email)
}
inline void UserDetails::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_ = new ::std::string;
  }
  email_->assign(value);
  // @@protoc_insertion_point(field_set_char:user.UserDetails.email)
}
inline void UserDetails::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:user.UserDetails.email)
}
inline ::std::string* UserDetails::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:user.UserDetails.email)
  return email_;
}
inline ::std::string* UserDetails::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserDetails::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:user.UserDetails.email)
}

// required string name = 2;
inline bool UserDetails::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserDetails::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserDetails::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserDetails::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& UserDetails::name() const {
  // @@protoc_insertion_point(field_get:user.UserDetails.name)
  return *name_;
}
inline void UserDetails::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:user.UserDetails.name)
}
inline void UserDetails::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:user.UserDetails.name)
}
inline void UserDetails::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:user.UserDetails.name)
}
inline ::std::string* UserDetails::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:user.UserDetails.name)
  return name_;
}
inline ::std::string* UserDetails::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserDetails::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:user.UserDetails.name)
}

// optional string address = 3;
inline bool UserDetails::has_address() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserDetails::set_has_address() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserDetails::clear_has_address() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserDetails::clear_address() {
  if (address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& UserDetails::address() const {
  // @@protoc_insertion_point(field_get:user.UserDetails.address)
  return *address_;
}
inline void UserDetails::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  address_->assign(value);
  // @@protoc_insertion_point(field_set:user.UserDetails.address)
}
inline void UserDetails::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  address_->assign(value);
  // @@protoc_insertion_point(field_set_char:user.UserDetails.address)
}
inline void UserDetails::set_address(const char* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:user.UserDetails.address)
}
inline ::std::string* UserDetails::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:user.UserDetails.address)
  return address_;
}
inline ::std::string* UserDetails::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserDetails::set_allocated_address(::std::string* address) {
  if (address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete address_;
  }
  if (address) {
    set_has_address();
    address_ = address;
  } else {
    clear_has_address();
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:user.UserDetails.address)
}

// optional bytes phone_number = 4;
inline bool UserDetails::has_phone_number() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserDetails::set_has_phone_number() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserDetails::clear_has_phone_number() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserDetails::clear_phone_number() {
  if (phone_number_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phone_number_->clear();
  }
  clear_has_phone_number();
}
inline const ::std::string& UserDetails::phone_number() const {
  // @@protoc_insertion_point(field_get:user.UserDetails.phone_number)
  return *phone_number_;
}
inline void UserDetails::set_phone_number(const ::std::string& value) {
  set_has_phone_number();
  if (phone_number_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phone_number_ = new ::std::string;
  }
  phone_number_->assign(value);
  // @@protoc_insertion_point(field_set:user.UserDetails.phone_number)
}
inline void UserDetails::set_phone_number(const char* value) {
  set_has_phone_number();
  if (phone_number_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phone_number_ = new ::std::string;
  }
  phone_number_->assign(value);
  // @@protoc_insertion_point(field_set_char:user.UserDetails.phone_number)
}
inline void UserDetails::set_phone_number(const void* value, size_t size) {
  set_has_phone_number();
  if (phone_number_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phone_number_ = new ::std::string;
  }
  phone_number_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:user.UserDetails.phone_number)
}
inline ::std::string* UserDetails::mutable_phone_number() {
  set_has_phone_number();
  if (phone_number_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phone_number_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:user.UserDetails.phone_number)
  return phone_number_;
}
inline ::std::string* UserDetails::release_phone_number() {
  clear_has_phone_number();
  if (phone_number_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = phone_number_;
    phone_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserDetails::set_allocated_phone_number(::std::string* phone_number) {
  if (phone_number_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete phone_number_;
  }
  if (phone_number) {
    set_has_phone_number();
    phone_number_ = phone_number;
  } else {
    clear_has_phone_number();
    phone_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:user.UserDetails.phone_number)
}

// optional bytes description = 5;
inline bool UserDetails::has_description() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserDetails::set_has_description() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserDetails::clear_has_description() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserDetails::clear_description() {
  if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& UserDetails::description() const {
  // @@protoc_insertion_point(field_get:user.UserDetails.description)
  return *description_;
}
inline void UserDetails::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(value);
  // @@protoc_insertion_point(field_set:user.UserDetails.description)
}
inline void UserDetails::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(value);
  // @@protoc_insertion_point(field_set_char:user.UserDetails.description)
}
inline void UserDetails::set_description(const void* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:user.UserDetails.description)
}
inline ::std::string* UserDetails::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:user.UserDetails.description)
  return description_;
}
inline ::std::string* UserDetails::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserDetails::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:user.UserDetails.description)
}

// optional bytes avatar = 6;
inline bool UserDetails::has_avatar() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserDetails::set_has_avatar() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserDetails::clear_has_avatar() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserDetails::clear_avatar() {
  if (avatar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_->clear();
  }
  clear_has_avatar();
}
inline const ::std::string& UserDetails::avatar() const {
  // @@protoc_insertion_point(field_get:user.UserDetails.avatar)
  return *avatar_;
}
inline void UserDetails::set_avatar(const ::std::string& value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
  // @@protoc_insertion_point(field_set:user.UserDetails.avatar)
}
inline void UserDetails::set_avatar(const char* value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
  // @@protoc_insertion_point(field_set_char:user.UserDetails.avatar)
}
inline void UserDetails::set_avatar(const void* value, size_t size) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:user.UserDetails.avatar)
}
inline ::std::string* UserDetails::mutable_avatar() {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:user.UserDetails.avatar)
  return avatar_;
}
inline ::std::string* UserDetails::release_avatar() {
  clear_has_avatar();
  if (avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = avatar_;
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserDetails::set_allocated_avatar(::std::string* avatar) {
  if (avatar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete avatar_;
  }
  if (avatar) {
    set_has_avatar();
    avatar_ = avatar;
  } else {
    clear_has_avatar();
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:user.UserDetails.avatar)
}

// -------------------------------------------------------------------

// UserConfig

// optional uint32 last_storage_id = 1;
inline bool UserConfig::has_last_storage_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserConfig::set_has_last_storage_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserConfig::clear_has_last_storage_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserConfig::clear_last_storage_id() {
  last_storage_id_ = 0u;
  clear_has_last_storage_id();
}
inline ::google::protobuf::uint32 UserConfig::last_storage_id() const {
  // @@protoc_insertion_point(field_get:user.UserConfig.last_storage_id)
  return last_storage_id_;
}
inline void UserConfig::set_last_storage_id(::google::protobuf::uint32 value) {
  set_has_last_storage_id();
  last_storage_id_ = value;
  // @@protoc_insertion_point(field_set:user.UserConfig.last_storage_id)
}

// optional uint32 last_group_id = 2;
inline bool UserConfig::has_last_group_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserConfig::set_has_last_group_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserConfig::clear_has_last_group_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserConfig::clear_last_group_id() {
  last_group_id_ = 0u;
  clear_has_last_group_id();
}
inline ::google::protobuf::uint32 UserConfig::last_group_id() const {
  // @@protoc_insertion_point(field_get:user.UserConfig.last_group_id)
  return last_group_id_;
}
inline void UserConfig::set_last_group_id(::google::protobuf::uint32 value) {
  set_has_last_group_id();
  last_group_id_ = value;
  // @@protoc_insertion_point(field_set:user.UserConfig.last_group_id)
}

// optional uint32 last_item_id = 3;
inline bool UserConfig::has_last_item_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserConfig::set_has_last_item_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserConfig::clear_has_last_item_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserConfig::clear_last_item_id() {
  last_item_id_ = 0u;
  clear_has_last_item_id();
}
inline ::google::protobuf::uint32 UserConfig::last_item_id() const {
  // @@protoc_insertion_point(field_get:user.UserConfig.last_item_id)
  return last_item_id_;
}
inline void UserConfig::set_last_item_id(::google::protobuf::uint32 value) {
  set_has_last_item_id();
  last_item_id_ = value;
  // @@protoc_insertion_point(field_set:user.UserConfig.last_item_id)
}

// optional uint32 last_parameter_id = 4;
inline bool UserConfig::has_last_parameter_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserConfig::set_has_last_parameter_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserConfig::clear_has_last_parameter_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserConfig::clear_last_parameter_id() {
  last_parameter_id_ = 0u;
  clear_has_last_parameter_id();
}
inline ::google::protobuf::uint32 UserConfig::last_parameter_id() const {
  // @@protoc_insertion_point(field_get:user.UserConfig.last_parameter_id)
  return last_parameter_id_;
}
inline void UserConfig::set_last_parameter_id(::google::protobuf::uint32 value) {
  set_has_last_parameter_id();
  last_parameter_id_ = value;
  // @@protoc_insertion_point(field_set:user.UserConfig.last_parameter_id)
}

// -------------------------------------------------------------------

// UserStatis

// optional uint32 magazineCount = 1;
inline bool UserStatis::has_magazinecount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserStatis::set_has_magazinecount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserStatis::clear_has_magazinecount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserStatis::clear_magazinecount() {
  magazinecount_ = 0u;
  clear_has_magazinecount();
}
inline ::google::protobuf::uint32 UserStatis::magazinecount() const {
  // @@protoc_insertion_point(field_get:user.UserStatis.magazineCount)
  return magazinecount_;
}
inline void UserStatis::set_magazinecount(::google::protobuf::uint32 value) {
  set_has_magazinecount();
  magazinecount_ = value;
  // @@protoc_insertion_point(field_set:user.UserStatis.magazineCount)
}

// optional uint32 totalNumOfElements = 2;
inline bool UserStatis::has_totalnumofelements() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserStatis::set_has_totalnumofelements() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserStatis::clear_has_totalnumofelements() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserStatis::clear_totalnumofelements() {
  totalnumofelements_ = 0u;
  clear_has_totalnumofelements();
}
inline ::google::protobuf::uint32 UserStatis::totalnumofelements() const {
  // @@protoc_insertion_point(field_get:user.UserStatis.totalNumOfElements)
  return totalnumofelements_;
}
inline void UserStatis::set_totalnumofelements(::google::protobuf::uint32 value) {
  set_has_totalnumofelements();
  totalnumofelements_ = value;
  // @@protoc_insertion_point(field_set:user.UserStatis.totalNumOfElements)
}

// optional uint32 totalNumOfUniqueElements = 3;
inline bool UserStatis::has_totalnumofuniqueelements() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserStatis::set_has_totalnumofuniqueelements() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserStatis::clear_has_totalnumofuniqueelements() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserStatis::clear_totalnumofuniqueelements() {
  totalnumofuniqueelements_ = 0u;
  clear_has_totalnumofuniqueelements();
}
inline ::google::protobuf::uint32 UserStatis::totalnumofuniqueelements() const {
  // @@protoc_insertion_point(field_get:user.UserStatis.totalNumOfUniqueElements)
  return totalnumofuniqueelements_;
}
inline void UserStatis::set_totalnumofuniqueelements(::google::protobuf::uint32 value) {
  set_has_totalnumofuniqueelements();
  totalnumofuniqueelements_ = value;
  // @@protoc_insertion_point(field_set:user.UserStatis.totalNumOfUniqueElements)
}

// optional uint32 totalNumOfRequests = 4;
inline bool UserStatis::has_totalnumofrequests() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserStatis::set_has_totalnumofrequests() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserStatis::clear_has_totalnumofrequests() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserStatis::clear_totalnumofrequests() {
  totalnumofrequests_ = 0u;
  clear_has_totalnumofrequests();
}
inline ::google::protobuf::uint32 UserStatis::totalnumofrequests() const {
  // @@protoc_insertion_point(field_get:user.UserStatis.totalNumOfRequests)
  return totalnumofrequests_;
}
inline void UserStatis::set_totalnumofrequests(::google::protobuf::uint32 value) {
  set_has_totalnumofrequests();
  totalnumofrequests_ = value;
  // @@protoc_insertion_point(field_set:user.UserStatis.totalNumOfRequests)
}

// optional uint32 totalModifiedItems = 5;
inline bool UserStatis::has_totalmodifieditems() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserStatis::set_has_totalmodifieditems() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserStatis::clear_has_totalmodifieditems() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserStatis::clear_totalmodifieditems() {
  totalmodifieditems_ = 0u;
  clear_has_totalmodifieditems();
}
inline ::google::protobuf::uint32 UserStatis::totalmodifieditems() const {
  // @@protoc_insertion_point(field_get:user.UserStatis.totalModifiedItems)
  return totalmodifieditems_;
}
inline void UserStatis::set_totalmodifieditems(::google::protobuf::uint32 value) {
  set_has_totalmodifieditems();
  totalmodifieditems_ = value;
  // @@protoc_insertion_point(field_set:user.UserStatis.totalModifiedItems)
}

// optional uint32 totalAddItems = 6;
inline bool UserStatis::has_totaladditems() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserStatis::set_has_totaladditems() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserStatis::clear_has_totaladditems() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserStatis::clear_totaladditems() {
  totaladditems_ = 0u;
  clear_has_totaladditems();
}
inline ::google::protobuf::uint32 UserStatis::totaladditems() const {
  // @@protoc_insertion_point(field_get:user.UserStatis.totalAddItems)
  return totaladditems_;
}
inline void UserStatis::set_totaladditems(::google::protobuf::uint32 value) {
  set_has_totaladditems();
  totaladditems_ = value;
  // @@protoc_insertion_point(field_set:user.UserStatis.totalAddItems)
}

// optional fixed64 last_login = 7;
inline bool UserStatis::has_last_login() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserStatis::set_has_last_login() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserStatis::clear_has_last_login() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserStatis::clear_last_login() {
  last_login_ = GOOGLE_ULONGLONG(0);
  clear_has_last_login();
}
inline ::google::protobuf::uint64 UserStatis::last_login() const {
  // @@protoc_insertion_point(field_get:user.UserStatis.last_login)
  return last_login_;
}
inline void UserStatis::set_last_login(::google::protobuf::uint64 value) {
  set_has_last_login();
  last_login_ = value;
  // @@protoc_insertion_point(field_set:user.UserStatis.last_login)
}

// optional fixed64 registration_date = 8;
inline bool UserStatis::has_registration_date() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserStatis::set_has_registration_date() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserStatis::clear_has_registration_date() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserStatis::clear_registration_date() {
  registration_date_ = GOOGLE_ULONGLONG(0);
  clear_has_registration_date();
}
inline ::google::protobuf::uint64 UserStatis::registration_date() const {
  // @@protoc_insertion_point(field_get:user.UserStatis.registration_date)
  return registration_date_;
}
inline void UserStatis::set_registration_date(::google::protobuf::uint64 value) {
  set_has_registration_date();
  registration_date_ = value;
  // @@protoc_insertion_point(field_set:user.UserStatis.registration_date)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace user

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_user_2eproto__INCLUDED
